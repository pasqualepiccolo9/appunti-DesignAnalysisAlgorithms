\chapter{Red-Black Trees e (2, 4) Trees}
\label{cap:RBT}

Abbiamo già parlato di alberi bilanciati nel Capitolo \ref{cap:AVL}, in particolare degli alberi AVL. Questo tipo di alberi consentiva di mantenere l'altezza dell'albero logaritmica rispetto al numero di nodi presenti, garantendo così operazioni di ricerca, inserimento e cancellazione efficienti. Tuttavia, una cancellazione in un albero AVL poteva richiedere molte rotazioni per mantenere l'equilibrio, rendendo l'operazione più costosa in termini di tempo.

\section{(2, 4) Trees}
I (2, 4) Trees sono semplicemente degli (a, b) Trees con $a = 2$ e $b = 4$. Ciò significa che ereditano tutte le proprietà degli (a, b) Trees discusse nel Capitolo \ref{cap:MWST}, e dal punto di vista di un'analisi asintotica, le performance di un (2, 4) Tree sono equivalenti a quelle di un albero AVL.
Per un (2, 4) Tree:
\begin{itemize}
    \item L'altezza è $O(\log n)$.
    \item Le operazioni di split, transfer e fusion hanno una complessità di $O(1)$.
    \item Le operazioni di ricerca, inserimento e cancellazione hanno una complessità di $O(\log n)$.
\end{itemize}

\noindent
All'interno di un (2, 4) Tree, ogni nodo può contenere da 1 a 3 chiavi e può avere da 2 a 4 figli. Questo consente di distinguere tra 2-nodi, 3-nodi e 4-nodi, sulla base del numero di figli (numero di chiavi + 1).
Questo tipo di alberi è particolarmente interessante per la sua relazione che ha con un tipo particolare di alberi, i \textbf{Red-Black Trees}.



\clearpage
\section{Red-Black Trees}
\paragraph{Definizione:} Un Red-Black Tree è un albero binario di ricerca in cui ogni nodo ha un colore: rosso o nero, e l'abero soddisfa le seguenti proprietà:
\begin{itemize}
    \item \textbf{Root Property:} La radice deve essere nera.
    \item \textbf{External Property:} Tutti i nodi foglia (None) sono neri.
    \item \textbf{Internal Property:} I figli di un nodo rosso sono neri.
    \item \textbf{Depth Property:} Tutti i nodi foglia (None) hanno la stessa \emph{black-depth}, ovvero il numero di antenati neri.
\end{itemize}

\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.8\textwidth]{immagini/RBT/RBT_example.png}
    \caption{Esempio di Red-Black Tree, con i nodi rossi disegnati in bianco. La black-depth di ogni nodo foglia è 3. Da notare che non sono disegnati i nodi foglia (None), che sono tutti neri.}
    \label{fig:RBT_example}
\end{figure}

Come abbiamo detto, i Red-Black Trees sono strettamente correlati ai (2, 4) Trees. Infatti, ogni (2, 4) Tree può essere rappresentato come un Red-Black Tree e viceversa. Un Red-Black Tree può essere visto come una rappresentazione binaria di un (2, 4) Tree, dove i nodi rossi rappresentano i nodi con più di una chiave nel (2, 4) Tree. Proprio per questo motivo, i Red-Black Trees mantengono le stesse performance dei (2, 4)-Trees, con il beneficio aggiuntivo di una implementazione più semplice e di una maggiore efficienza nelle operazioni di inserimento e cancellazione, che richiedono al massimo una o due rotazioni per mantenere l'equilibrio dell'albero.


\clearpage
\section{Dal (2, 4)-Tree al Red-Black Tree}

\begin{itemize}
    \item Colora di nero tutti i nodi del (2, 4) Tree.
    \item Per ogni nodo $w$:
    \begin{itemize}
        \item Se $w$ è un 2-nodo, mantieni i figli (neri) di $w$ così come sono.
        \item Se $w$ è un 3-nodo, crea un nuovo nodo rosso $y$, figlio destro (o sinistro) di $w$, e fai in modo che gli ultimi due (o i primi due) figli di $w$ diventino figli di $y$, e il primo figlio (o l'ultimo) di $w$ rimanga figlio di $w$.
        \item Se $w$ è un 4-nodo con chiavi $k_1$, $k_2$ e $k_3$, rappresentalo come un nodo nero con due figli rossi contenenti le chiavi $k_2$ e $k_3$.
    \end{itemize}
\end{itemize}

\noindent
Da notare che seguendo l'algoritmo sopra descritto, un nodo rosso avrà sempre un genitore nero.

\begin{figure}[ht!]
    \centering
    \includegraphics[width=1\textwidth]{immagini/RBT/24toRB.png}
    \label{fig:24toRB}
\end{figure}



\section{Dal Red-Black Tree al (2, 4)-Tree}

\begin{itemize}
    \item  Ogni nodo rosso $w$ viene unito con il suo genitore nero $p$ per formare un unico nodo del (2, 4) Tree.
    \begin{itemize}
        \item L'elemento in $w$ viene aggiunto alle chiavi in $p$.
        \item I figli di $w$ diventano figli di $p$.
    \end{itemize}
\end{itemize}

\begin{figure}[ht!]
    \centering
    \includegraphics[width=1\textwidth]{immagini/RBT/RBto24.png}
    \label{fig:RBto24}
\end{figure}



\section{Altezza di un Red-Black Trees}
Sia $T$ un Red-Black Tree con $n$ nodi interni e altezza $h$, allora vale la seguente disuguaglianza:
\[ 
\log (n + 1) -1 \le h \le 2 \log(n + 1) - 2 
\]
Sia $d$ la black-depth di $T$. Sia $T'$ il (2, 4)-Tree associato a $T$, e sia $h'$ l'altezza di $T'$. Per via della corrispondenza tra $T$ e $T'$, vale la relazione $h' = d$. Quindi, si ha che $d = h' \le \log (n + 1) - 1$, da cui si ricava che $h \le 2d \le 2 \log(n + 1)$. Sappiamo inoltre che vale la seguente proprietà: $h' \le 2d$. Quindi, otteniamo $h \le 2 \log (n + 1) - 2$. L'altra disuguaglianza, $ \log (n + 1) -1 \le h $ deriva dalle proprietà di un qualsiasi albero binario.



\section{Insert}
Per inserire un nuovo nodo in un Red-Black Tree, si segue lo stesso procedimento di un normale BST:
\begin{itemize}[nosep]
    \item Se il nuovo nodo $z$ è la radice, coloralo di nero.
    \item Altrimenti, inseriscilo come un nodo rosso.
\end{itemize} 
\noindent
L'inserimento eseguito in questo modo mantiene di già le Root, External, e Depth Properties. Tuttavia, potrebbe violare la Internal Property in alcuni casi:
\begin{itemize}[nosep]
    \item Se il genitore di $z$ è nero, anche la Internal Property è mantenuta.
    \item Se il genitore di $z$ è rosso, la Internal Property viene violata in quanto si ottiene una sequenza di due nodi rossi, un \textbf{double red}. In questo caso, bisogna ristrutturare l'albero per ripristinare le proprietà dei Red-Black Trees.
\end{itemize}

\subsection{Come risolvere un double red}
Siano $z$ e il suo genitore $v$ entrambi rossi, e sia $w$ il fratello di $v$ (lo zio di $z$).
\begin{itemize}[nosep]
    \item Se $w$ è nero (o None), il double-red corrisponde ad una trasformazione sbagliata di un 4-nodo nel (2, 4)-Tree corrispondente.
    \begin{itemize}[nosep]
        \item Si esegue una \textbf{ristrutturazione} (Three-node restructuring, singola o doppia rotazione) su $z$.
        \item Dopo la ristrutturazione, il nodo che diventa la radice della porzione ristrutturata viene colorato di nero, mentre i suoi due figli vengono colorati di rosso.
        \item Una sola ristrutturazione è sufficiente per risolvere il problema del double-red.
    \end{itemize}
    \item Se $w$ è rosso, il double-red corrisponde ad un overflow e quindi in un 5-nodo nel (2, 4)-Tree corrispondente.
    \begin{itemize}[nosep]
        \item Si esegue una \textbf{ricolorazione} (recolouring) colorando $v$ e $w$ di nero, mentre il loro genitore $u$ (genitore di $v$ e $w$, e nonno di $z$) viene colorato di rosso (se $u$ non è la radice).
        \item In questo caso il double-red può propagarsi verso l'alto, quindi potrebbe essere necessario ripetere la procedura sul nodo $u$ e il suo genitore.
    \end{itemize}
\end{itemize}

\clearpage
\begin{figure}[ht!]
    \centering
    \includegraphics[width=1\textwidth]{immagini/RBT/RBT_insert.png}
    \caption{Una sequenza di inserimenti in un albero rosso-nero: (a) albero iniziale; (b) inserimento di 7; (c) inserimento di 12, che causa un double red; (d) dopo la ristrutturazione; (e) inserimento di 15, che causa un double red; (f ) dopo la ricolorazione (la radice rimane nera); (g) inserimento di 3; (h) inserimento di 5; (i) inserimento di 14, che causa un double red; (j) dopo la ristrutturazione; (k) inserimento di 18, che causa un double red; (l) dopo la ricolorazione.}
    \label{fig:RBT_insert}
\end{figure}


\subsection{Complessità dell'inserimento}
Come abbiamo visto, l'inserimento in un Red-Black Tree richiede una prima operazione di ricerca di $O(\log n)$ per trovare la posizione corretta del nuovo nodo, la creazione di un nuovo nodo in $O(1)$, e infine possono essere necessarie al massimo $O(\log n)$ ricolorazioni (ciascuna impiega $O(1)$) e al più una sola ristrutturazione ($O(1)$) per mantenere le proprietà dell'albero. 

Pertanto, la complessità totale dell'inserimento in un Red-Black Tree è $O(\log n)$.



\section{Delete}
Per eliminare un nuovo nodo con chiave $k$ in un Red-Black Tree, si segue lo stesso procedimento di un normale BST:

\begin{itemize}
    \item \uline{Ciò vuol dire che eliminiamo sempre un nodo con al più un solo figlio}. Il nodo eliminato contiene una chiave $k$ o il suo predecessore/successore (in base all'implementazione) in ordine. Il nodo figlio di quello eliminato (se esiste) viene promosso a figlio del genitore del nodo eliminato.
\end{itemize} 


\subsection{Caso 1: Delete di un nodo rosso}
Se il nodo eliminato è rosso, tutte le proprietà dei Red-Black Trees rimangono valide, poiché la rimozione di un nodo rosso non altera la black depth di alcun percorso dalla radice a una foglia, e poiché questa operazione non può introdurre un double red. 

\vspace{1\baselineskip}
Nel corrispondente (2, 4)-Tree, la rimozione di un nodo rosso equivale alla rimozione di una chiave da un 3-nodo o da un 4-nodo, il che è sempre consentito senza ulteriori modifiche.

\subsection{Caso 2: Delete di un nodo nero con un solo figlio (rosso)}
\uline{Ricordiamo che stiamo trattando la rimozione di nodi con al più un figlio (per via della delete in un BST).} 
Se il nodo da eliminare è nero e ha un figlio, questo sarà sicuramente rosso (altrimenti la black depth property non sarebbe soddisfatta e non si avrebbe un Red-Black Tree valido).
In questo caso, possiamo semplicemente rimuovere il nodo nero e promuovere il figlio rosso al suo posto, colorandolo di nero, ristabilendo tutte le proprietà dei Red-Black Trees. 

\vspace{1\baselineskip}
Nel corrispondente (2, 4)-Tree, questa operazione equivale alla rimozione del nodo nero da un 3-nodo.

\vspace{8\baselineskip}
\noindent
Infine, consideriamo il caso più complesso, in cui il nodo da eliminare è un nodo nero senza figli.

\clearpage
\subsection{Caso 3: Delete di un nodo nero senza figli}
Il caso più complesso si verifica quando il nodo da eliminare è un nodo nero senza figli. Nel corrispondente (2, 4)-Tree, questa situazione equivale alla rimozione di una chiave da un 2-nodo. Senza un ribilanciamento, una modifica del genere comporta un deficit di uno per la black depth lungo il percorso che porta al nodo eliminato, violando così la Depth Property dei Red-Black Trees. 

Per rimediare a questo scenario, consideriamo un contesto più generale con un nodo $z$ che è noto per avere due sottoalberi, $T_{\text{heavy}}$ e $T_{\text{light}}$, tale che la radice di $T_{\text{light}}$ (se presente) è nera e tale che la black depth di $T_{\text{heavy}}$ è esattamente uno in più rispetto a quella di $T_{\text{light}}$, come illustrato in Figura \ref{fig:RBT_delete_deficit}. Nel caso di una foglia nera rimossa, $z$ è il genitore di quella foglia e $T_{\text{light}}$ è banalmente il sottoalbero vuoto che rimane dopo la cancellazione. Descriviamo il caso più generale di un deficit perché il nostro algoritmo per il ribilanciamento dell'albero, in alcuni casi, spingerà il deficit più in alto nell'albero (proprio come la risoluzione di una cancellazione in un (2,4) tree a volte si propaga verso l'alto). Indichiamo con $y$ la radice di $T_{\text{heavy}}$ (Un tale nodo esiste perché $T_{\text{heavy}}$ ha altezza nera almeno uno).

\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.4\textwidth]{immagini/RBT/RBT_delete_deficit.png}
    \caption{Illustrazione di un deficit tra le altezze nere dei sottoalberi del nodo $z$. Il colore grigio nell'illustrare $y$ e $z$ denota il fatto che questi nodi possono essere colorati sia di nero che di rosso.}
    \label{fig:RBT_delete_deficit}
\end{figure}

\noindent
Ricapitolando:
\begin{itemize}[nosep]
    \item $z$ è un nodo con due sottoalberi $T_{\text{heavy}}$ e $T_{\text{light}}$, tali che:
    \begin{itemize}[nosep]
        \item $T_{\text{heavy}}$ ha altezza nera $d$.
        \item $T_{\text{light}}$ ha altezza nera $d - 1$.
    \end{itemize}
    \item $y$ è la radice di $T_{\text{heavy}}$, la quale esiste sempre.
    \item $z$ e $y$ possono essere sia rossi che neri.
\end{itemize}

\vspace{1\baselineskip}
\noindent
Distinguiamo tre possibili casi:
\begin{itemize}
    \item Nodo $y$ nero con (almeno) un figlio rosso $x$.
    \item Nodo $y$ nero e entrambi i figli di $y$ sono neri (o None).
    \item Nodo $y$ rosso.
\end{itemize}


\clearpage
\subsubsection{Caso 3.1: Nodo $y$ nero con (almeno) un figlio rosso $x$}
\paragraph{Soluzione:} Si esegue una \emph{ristrutturazione} \texttt{restructure(x)} sui tre nodi $x$, il suo genitore $y$, e il nonno $z$, rinominati temporaneamente come $a$, $b$, e $c$ in ordine di chiave. Sostituiamo $z$ con il nodo etichettato $b$, rendendolo il genitore degli altri due. Coloriamo $a$ e $c$ di nero, e diamo a $b$ il colore precedente di $z$.

\begin{figure}[ht!]
    \centering
    \includegraphics[width=1\textwidth]{immagini/RBT/RBT_delete_case1.png}
    \caption{Risoluzione di un deficit nero in $T_\text{light}$ attraverso una ristrutturazione su tre nodi \texttt{restructure(x)}. Sono mostrate due possibili configurazioni (le altre due sono simmetriche). Il colore grigio di $z$ nelle figure a sinistra denota il fatto che questo nodo può essere colorato sia di rosso che di nero. La radice della porzione ristrutturata assume lo stesso colore, mentre i figli di quel nodo sono entrambi colorati di nero nel risultato.}
    \label{fig:RBT_delete_case1}
\end{figure}

\vspace{1\baselineskip}
Nel caso in cui $y$ abbia entrambi i figli rossi, possiamo scegliere arbitrariamente uno dei due come $x$. Altrimenti, scegliamo l'unico figlio rosso di $y$ come $x$. Da notare che il percorso verso $T_{\text{light}}$ include un nodo nero aggiuntivo dopo la ristrutturazione, risolvendo così il suo deficit. Al contrario, il numero di nodi neri sui percorsi verso ciascuno degli altri tre sottoalberi illustrati in Figura \ref{fig:RBT_delete_case1} rimane invariato.

\vspace{1\baselineskip}
Risolvere questo caso corrisponde a un'operazione di \emph{transfer} nell'albero (2,4) $T'$ tra i due figli del nodo con $z$. Il fatto che $y$ abbia un figlio rosso ci assicura che rappresenta o un 3-nodo o un 4-nodo. In effetti, l'elemento precedentemente memorizzato in $z$ viene declassato per diventare un nuovo 2-nodo per risolvere la carenza, mentre un elemento memorizzato in $y$ o nel suo figlio viene promosso per prendere il posto dell'elemento precedentemente memorizzato in $z$.



\clearpage
\subsubsection{Caso 3.2: Nodo $y$ nero e entrambi i figli di $y$ sono neri (o None)}
\paragraph{Soluzione:} Si esegue una \emph{ricolorazione}, per cui coloriamo $y$ di rosso e, se $z$ è rosso, lo coloriamo di nero. 
\begin{itemize}[nosep]
    \item Se $z$ era originariamente rosso, questa ricolorazione risolve il deficit.
    \item Se $z$ era originariamente nero, la ricolorazione non risolve il deficit, ma lo propaga più in alto nell'albero; dobbiamo ripetere la considerazione di tutti e tre i casi sul genitore di $z$ come rimedio.
\end{itemize}
\noindent
Questa ricolorazione non introduce alcun double-red, poiché $y$ non ha figli rossi.


\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.8\textwidth]{immagini/RBT/RBT_delete_case2.png}
    \caption{Risoluzione di un deficit nero in $T_\text{light}$ tramite una ricolorazione. (a) quando $z$ è originariamente rosso, si invertono i colori di $y$ e $z$ per risolvere il deficit nero in $T_\text{light}$, terminando il processo; (b) quando $z$ è originariamente nero, la ricolorazione di $y$ causa un deficit nero nell'intero sottoalbero di $z$, trasportando il problema ad un livello superiore che andrà risolto seguendo uno dei tre casi descritti.}
    \label{fig:RBT_delete_case2}
\end{figure}

\vspace{1\baselineskip}
\noindent
La soluzione in questo caso corrisponde all'operazione di \emph{fusion} nell'albero (2, 4) $T'$, poiché $y$ deve rappresentare un 2-nodo. 
Nel caso in cui $z$ era originariamente rosso, e quindi il genitore nel corrispondente albero (2,4) è un 3-nodo o un 4-nodo, questa ricolorazione risolve il deficit. (Vedi Figura \ref{fig:RBT_delete_case2}a.) Il percorso che porta a $T_{\text{light}}$ include un nodo nero aggiuntivo nel risultato, mentre la ricolorazione non ha influenzato il numero di nodi neri sul percorso verso i sottoalberi di $T_{\text{heavy}}$. Nel caso in cui $z$ fosse originariamente nero, e quindi il genitore nel corrispondente albero (2, 4) è un 2-nodo, la ricolorazione non ha aumentato il numero di nodi neri sul percorso verso $T_{\text{light}}$; in effetti, ha ridotto il numero di nodi neri sul percorso verso $T_{\text{heavy}}$. (Vedi Figura \ref{fig:RBT_delete_case2}b.) Dopo questo passaggio, i due figli di $z$ avranno la stessa altezza nera. Tuttavia, l'intero albero radicato in $z$ è diventato carente, propagando così il problema più in alto nell'albero; dobbiamo ripetere la considerazione di tutti e tre i casi sul genitore di $z$ come rimedio.




\clearpage
\subsubsection{Caso 3.3: Nodo $y$ rosso}
\paragraph{Soluzione:} Si esegue una \emph{rotazione} su $y$ e $z$, seguita da una ricolorazione di $y$ in nero e di $z$ in rosso. Inoltre, poichè $y$ era originariamente rosso, il nuovo sottoalbero di $z$ deve avere una radice nera $y'$ e deve avere un'altezza nera uguale a quella originale di $T_{\text{heavy}}$. Pertanto, un deficit nero rimane nel nodo $z$ dopo la trasformazione, e quindi riapplichiamo l'algoritmo per risolvere il deficit in $z$, sapendo che il nuovo figlio $y'$, che è la radice di $T_{\text{heavy}}$ è ora nero, e quindi che si applica o il Caso 3.1 o il Caso 3.2. Inoltre, la prossima applicazione sarà l'ultima, perché il Caso 3.1 è sempre terminale e il Caso 3.2 sarà terminale dato che $z$ è rosso.

\begin{figure}[ht!]
    \centering
    \includegraphics[width=1\textwidth]{immagini/RBT/RBT_delete_case3.png}
    \caption{Una rotazione e una ricolorazione su un nodo rosso $y$ e un nodo nero $z$, assumendo un deficit nero in $z$. Questo equivale a un cambiamento di orientamento nel corrispondente 3-nodo di un albero (2,4). Questa operazione non influisce sull'altezza nera di alcun percorso attraverso questa porzione dell'albero. Inoltre, poiché $y$ era originariamente rosso, il nuovo sottoalbero di $z$ deve avere una radice nera $y'$ e deve avere un'altezza nera uguale a quella originale di $T_{\text{heavy}}$. Pertanto, un deficit nero rimane nel nodo $z$ dopo la trasformazione.}
    \label{fig:RBT_delete_case3}
\end{figure}

\vspace{1\baselineskip}
Da notare che inizialmente $y$ è rosso e $T_{\text{heavy}}$ ha altezza nera almeno 1, $z$ deve essere nero e i due sottoalberi di $y$ devono avere ciascuno una radice nera e un'altezza nera uguale a quella di $T_{\text{heavy}}$.

\vspace{1\baselineskip}
Le prime operazioni di rotazione e ricolorazione denotano una riorientazione di un 3-nodo nel corrispondente albero (2,4) $T'$.


\clearpage
\begin{figure}[ht!]
    \centering
    \includegraphics[width=1\textwidth]{immagini/RBT/RBT_delete_example.png}
    \caption{Una sequenza di cancellazioni da un Red-Black Tree: (a) albero iniziale; (b) rimozione di 3; (c) rimozione di 12, che causa un deficit nero a destra di 7 (risolto tramite ristrutturazione); (d) dopo la ristrutturazione; (e) rimozione di 17; (f) rimozione di 18, che causa un deficit nero a destra di 16 (risolto tramite ricolorazione); (g) dopo la ricolorazione; (h) rimozione di 15; (i) rimozione di 16, che causa un deficit nero a destra di 14 (risolto inizialmente tramite una rotazione); (j) dopo la rotazione il deficit nero deve essere risolto tramite una ricolorazione; (k) dopo la ricolorazione.}
    \label{fig:RBT_delete_example}
\end{figure}



\clearpage
\subsection{Complessità della cancellazione}
L'algoritmo per eliminare un elemento da un Red-Black Tree con $n$ elementi richiede $O(\log n)$ tempo e esegue $O(\log n)$ ricolorazioni e al massimo due operazioni di ristrutturazione.


\subsection*{Riepilogo Delete}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=1\textwidth]{immagini/RBT/RBT_delete_summary.png}
    \caption{Riepilogo dei casi di delete in un Red-Black Tree.}
    \label{fig:RBT_delete_summary}
\end{figure}


