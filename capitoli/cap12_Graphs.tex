\chapter{Graphs}
\label{cap:Graphs}

Un \textbf{grafo} è una struttura matematica che può essere utilizzata per rappresentare un insieme di relazioni binarie tra coppie di oggetti in una collezione: gli oggetti sono chiamati \textbf{vertici} (o nodi) e le relazioni tra di essi sono chiamate \textbf{archi}. 

\paragraph{Definizione:} Un grafo $G$ è una coppia ordinata $(V,E)$ dove $V = \{v_1, v_2, \ldots, v_n\}$ è un insieme non vuoto di vertici e $E = \{u, v\}$ è una collezione di coppie di vertici (archi) di $V$. 

\noindent
Un arco può essere \emph{orientato} o \emph{non orientato}. \begin{itemize}[nosep]
    \item Un arco $(u,v)$ è orientato se la coppia $(u,v)$ è ordinata, con $u$ che precede $v$. Il primo vertice, $u$, è chiamato \emph{sorgente} e il secondo vertice, $v$, è chiamato \emph{destinazione}. Rappresenta una relazione unidirezionale (asimmetrica) da $u$ a $v$.
    \item Un arco $(u,v)$ è non orientato se la coppia $(u,v)$ non è ordinata. Entrambi i vertici sono chiamati \emph{estremi} dell'arco. Rappresenta una relazione bidirezionale (simmetrica) tra $u$ e $v$.
\end{itemize}

\noindent
Se tutti gli archi di un grafo sono orientati, allora si dice che il grafo è un \emph{grafo orientato}. Allo stesso modo, un \emph{grafo non orientato} è un grafo i cui archi sono tutti non orientati. Un grafo che ha sia archi orientati che non orientati è chiamato \emph{grafo misto}.

\vspace{2\baselineskip}
\noindent
La teoria dei grafi rappresenta una pietra miliare dell'informatica teorica e applicata, offrendo un linguaggio formale per modellare le relazioni tra oggetti. Questa struttura è onnipresente: dai \textit{social network}, dove i nodi rappresentano gli utenti e gli archi le amicizie, alle reti di calcolatori e ai sistemi di navigazione satellitare. Algoritmi fondamentali, come quello di \textbf{Dijkstra} per il calcolo del cammino minimo o l'algoritmo \textbf{PageRank} di Google, si basano interamente sulle proprietà topologiche dei grafi. Senza l'astrazione fornita dai grafi, la risoluzione efficiente di problemi complessi di connettività, flusso e ottimizzazione sarebbe pressoché impossibile.



\clearpage
\paragraph{Terminologia sui Grafi:}
Con riferimento al grafo mostrato in Figura \ref{fig:term_graph}:
\begin{itemize}[nosep]
    \item \textbf{Estremi di un arco}: Gli estremi di un arco sono i vertici collegati dallo stesso arco. $u$ e $v$ sono gli estremi dell'arco $a$. 
    \item \textbf{Vertici adiacenti}: Due vertici sono adiacenti se esiste un arco che li collega. $u$ e $v$ sono vertici adiacenti. 
    \item \textbf{Archi incidenti in un vertice}: Gli archi incidenti in un vertice sono gli archi che hanno quel vertice come estremo. $a$, $b$, $d$ sono archi incidenti in $v$. 
    \item \textbf{Grado di un vertice}: Il grado di un vertice $v$ è il numero di archi incidenti in $v$. $x$ ha grado 5.
    \item \textbf{Archi paralleli}: Due archi sono paralleli se collegano gli stessi vertici. $h$ e $i$ sono archi paralleli.
\end{itemize}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.4\textwidth]{immagini/Graphs/term_graph.png}
    \caption{}
    \label{fig:term_graph}
\end{figure}


\paragraph{Terminologia sui Grafi Orientati:}
Con riferimento al grafo mostrato in Figura \ref{fig:term_digraph}:
\begin{itemize}[nosep]
    \item \textbf{Archi entranti in un vertice}: Gli archi entranti in un vertice sono gli archi che hanno quel vertice come destinazione. $b$, $e$, $h$ sono archi entranti in $x$.
    \item \textbf{Archi uscenti da un vertice}: Gli archi uscenti da un vertice sono gli archi che hanno quel vertice come sorgente. $g$, $i$, sono archi uscenti da $x$.
    \item \textbf{In-degree}: L'in-degree di un vertice è il numero di archi entranti in esso. $x$ ha in-degree 3.
    \item \textbf{Out-degree}: L'out-degree di un vertice è il numero di archi uscenti da esso. $vx$ ha out-degree 3.
\end{itemize}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.4\textwidth]{immagini/Graphs/term_digraph.png}
    \caption{}
    \label{fig:term_digraph}
\end{figure}


\clearpage
\noindent
Un \textbf{cammino} (o percorso, path) in un grafo è una sequenza di vertici collegati da archi, ovvero una sequenza di vertici $(v_1, v_2, \ldots, v_k)$ tale che $(v_i, v_{i+1})$ è un arco del grafo, per $i = 1, 2, \ldots, k-1$. 
È anche possibile vedere un cammino come una sequenza di archi $(e_1, e_2, \ldots, e_{k-1})$ tale che l'estremo di destinazione di $e_i$ è l'estremo sorgente di $e_{i+1}$, per $i = 1, 2, \ldots, k-1$.
Un \textbf{cammino semplice} non visita uno stesso vertice più di una volta. 


Un \textbf{cammino orientato} in un grafo orientato è una sequenza di vertici $(v_1, v_2, \ldots, v_k)$ tale che ogni arco $(v_i, v_{i+1})$ è un arco orientato del grafo, per $i = 1, 2, \ldots, k-1$.

\begin{figure}[!ht]
    \centering
    % Inizio prima figura (sinistra)
    \begin{minipage}[t]{0.4\textwidth}
        \centering
        \includegraphics[width=\linewidth]{immagini/Graphs/term_paths.png}
        \caption{$P_1 = (v, x, z)$ è un cammino semplice; $P_2 = (u, w, x, y, w, v)$ è un cammino ma non semplice.}
        \label{fig:term_paths}
    \end{minipage}
    \hfill % Spazio flessibile tra le due figure
    % Inizio seconda figura (destra)
    \begin{minipage}[t]{0.4\textwidth}
        \centering
        \includegraphics[width=\linewidth]{immagini/Graphs/term_paths1.png}
        \caption{$P_1 = (v, x, z)$ è un cammino orientato semplice; $P_2 = (u, w, x, y, w, v)$ è un cammino orientato ma non semplice.}
        \label{fig:term_paths1}
    \end{minipage}
\end{figure}


\noindent
Un \textbf{ciclo} in un grafo è un cammino che inizia e termina nello stesso vertice, con almeno un arco. Un \textbf{ciclo semplice} non visita uno stesso vertice più di una volta, ad eccezione del vertice iniziale/finale. Un \textbf{auto-ciclo} è un ciclo che consiste in un singolo arco che collega un vertice a se stesso.
\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.4\textwidth]{immagini/Graphs/term_loops.png}
    \caption{$C_1 = (v, x, y, w, u, v)$ è un ciclo semplice; $C_2 = (u, w, x, y, w, v, u)$ è un ciclo ma non semplice.}
    \label{fig:term_loops}
\end{figure}


\clearpage
\section*{Proprietà di un Grafo non orientato}
Siano $n$ il numero di vertici e $m$ il numero di archi di un grafo non orientato (Figura \ref{fig:prop_graph}).
\begin{enumerate}
    \item $\sum\limits_{v \in V} \text{deg}(v) = 2m$, dove la somma è calcolata su tutti i vertici $v$ del grafo. 
    \begin{itemize}
        \item Questo perché ogni arco contribuisce a incrementare il grado di due vertici.
    \end{itemize}
    \item In un grafo non orientato senza archi paralleli e auto-cicli, il numero massimo di archi è dato da $m \le \frac{n(n-1)}{2}$. 
    \begin{itemize}
        \item Per via delle ipotesi di cui sopra, ciascun nodo può avere grado massimo $(\le) n-1$. Riprendendo la proprietà precedente, si ha quindi che $2m \le n(n-1)$.
    \end{itemize}
\end{enumerate}

\vspace{1\baselineskip}
\begin{figure}[!ht]
    \centering
    % Inizio prima figura (sinistra)
    \begin{minipage}[t]{0.4\textwidth}
        \centering
        \includegraphics[width=\linewidth]{immagini/Graphs/prop_graph.png}
        \caption{}
        \label{fig:prop_graph}
    \end{minipage}
    \hfill % Spazio flessibile tra le due figure
    % Inizio seconda figura (destra)
    \begin{minipage}[t]{0.4\textwidth}
        \centering
        \includegraphics[width=\linewidth]{immagini/Graphs/prop_digraph.png}
        \caption{}
        \label{fig:prop_digraph}
    \end{minipage}
\end{figure}


\section*{Proprietà di un Grafo orientato}
Siano $n$ il numero di vertici e $m$ il numero di archi di un grafo orientato (Figura \ref{fig:prop_digraph}).
\begin{enumerate}
    \item $\sum\limits_{v \in V} \text{in-deg}(v) = \sum\limits_{v \in V} \text{out-deg}(v) = m$, dove la somma è calcolata su tutti i vertici del grafo.
    \begin{itemize}
        \item Questo perché ogni arco contribuisce di uno all'in-degree di un vertice e di uno all'out-degree di un altro vertice.
    \end{itemize}
    \item In un grafo orientato senza archi paralleli e auto-cicli, il numero massimo di archi è dato da $m \le n(n-1)$. 
    \begin{itemize}
        \item Per via delle ipotesi di cui sopra, ciascun nodo può avere grado massimo $(\le) n-1$. Riprendendo la proprietà precedente, si ha quindi che $m \le n(n-1)$.
    \end{itemize}
\end{enumerate}


\clearpage
\noindent
Due vertici $u,v$ di un grafo (orientato) sono \textbf{connessi} se esiste un cammino (orientato) da $u$ a $v$. In un grafo non orientato, la \emph{connettività} è una relazione simmetrica. In un grafo orientato, invece, la connettività non è necessariamente simmetrica: potrebbe esistere un cammino da $u$ a $v$ ma non da $v$ a $u$.

Un grafo non orientato si dice \textbf{connesso} se, per ogni coppia di vertici, esiste un cammino tra di essi. Un grafo orientato è \textbf{debolmente connesso} se, ignorando l'orientamento degli archi, il grafo non orientato risultante è connesso. Un grafo orientato è \textbf{fortemente connesso} se per ogni coppia di vertici $(u,v)$, $u$ raggiunge $v$ e $v$ raggiunge $u$.

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.55\textwidth]{immagini/Graphs/connectivity.png}
    \caption{Esempi di grafi connessi e non connessi.}
    \label{fig:connectivity}
\end{figure}

\vspace{1\baselineskip}
\noindent
Una \textbf{forest} è un grafo non orientato e aciclico (ovvero privo di cicli). Un \textbf{tree} è una forest connessa. In altre parole, un tree è un grafo non orientato, aciclico e connesso.


\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.55\textwidth]{immagini/Graphs/tree_forest.png}
    \caption{Esempi di tree e forest.}
    \label{fig:tree_forest}
\end{figure}

\noindent
Un \textbf{sottografo} $H$ di un grafo $G = (V,E)$ è un grafo $H = (V', E')$ tale che $V' \subseteq V$ e $E' \subseteq E$. In altre parole, un sottografo è ottenuto rimuovendo vertici e/o archi da $G$. Uno \textbf{spanning subgraph} (la traduzione corretta è "sottografo ricoprente") di un grafo $G = (V,E)$ è un sottografo $H = (V', E')$ tale che $V' = V$. In altre parole, uno spanning subgraph contiene tutti i vertici di $G$, ma potrebbe non contenere tutti gli archi di $G$. 

Uno \textbf{spanning tree} di un grafo è uno spanning subgraph che è anche un tree (ricordiamo, tree = grafo non orientato, aciclico e connesso).


\vspace{1\baselineskip}
\noindent
Dato un grafo non orientato $G$ con $n$ vertici e $m$ archi:
\begin{itemize}[nosep]
    \item Se $G$ è connesso, allora $m \ge n-1$.
    \item Se $G$ è una forest, allora $m \le n-1$.
    \item Se $G$ è un tree, allora $m = n-1$.
\end{itemize}



\clearpage
\section{Rappresentazioni dell'ADT Grafo}
Esistono diverse rappresentazioni possibili di un grafo. In ognuna di esse, mantieniamo una collezione per memorizzare i vertici di un grafo. Tuttavia, le rappresentazioni differiscono notevolmente nel modo in cui organizzano gli archi.

\begin{itemize}
    \item \textbf{Edge List}: in un edge list, manteniamo una lista non ordinata di tutti gli archi. Questo è il minimo indispensabile, ma non esiste un modo efficiente per localizzare un particolare arco (u,v), o l'insieme di tutti gli archi incidenti a un vertice v.
    \item \textbf{Adjacency List}: in un adjacency list, manteniamo, per ogni vertice, una lista separata contenente quegli archi che sono incidenti al vertice. L'insieme completo degli archi può essere determinato prendendo l'unione dei set più piccoli, mentre l'organizzazione consente di trovare in modo più efficiente tutti gli archi incidenti a un dato vertice.
    \item \textbf{Adjacency Map}: un adjacency map è molto simile a un adjacency list, ma il contenitore secondario di tutti gli archi incidenti a un vertice è organizzato come una mappa, anziché come una lista, con il vertice adiacente che funge da chiave. Ciò consente l'accesso a un arco specifico (u,v) in tempo O(1) atteso.
    \item \textbf{Adjacency Matrix}: un adjacency matrix fornisce un accesso nel caso peggiore O(1) a un arco specifico (u,v) mantenendo una matrice n×n, per un grafo con n vertici. Ogni voce è dedicata a memorizzare un riferimento all'arco (u,v) per una particolare coppia di vertici u e v; se non esiste tale arco, la voce sarà None.
\end{itemize}

\vspace{1\baselineskip}
\begin{figure}[!ht]
    \centering
    \includegraphics[width=1\textwidth]{immagini/Graphs/adt_graph.png}
    \caption{Un riepilogo dei tempi di esecuzione per i metodi dell'ADT grafo, utilizzando le rappresentazioni del grafo discusse in questa sezione. Indichiamo con $n$ il numero di vertici, $m$ il numero di archi, e $d_v$ il grado del vertice $v$. Si noti che la matrice di adiacenza utilizza uno spazio $O(n^2)$, mentre tutte le altre strutture utilizzano uno spazio $O(n+m)$.}
    \label{fig:adt_graph}
\end{figure}


\clearpage
\section{Rappresentazione mediante Edge List}
L'\emph{edge list} è la rappresentazione più semplice possibile di un grafo, anche se non la più efficiente. Tutti gli oggetti vertice sono memorizzati in una lista non ordinata $V$, e tutti gli oggetti arco sono memorizzati in una lista non ordinata $E$.


\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.75\textwidth]{immagini/Graphs/edge_list.png}
    \caption{(a) Un grafo $G$; (b) rappresentazione schematica della struttura edge list per $G$. Si noti che un oggetto arco fa riferimento ai due oggetti vertice che corrispondono ai suoi estremi, ma che i vertici non fanno riferimento agli archi incidenti per cui non mantengono questa informazione.}
    \label{fig:edge_list}
\end{figure}

\noindent
Per supportare i metodi dell'ADT Grafo, assumiamo le seguenti caratteristiche aggiuntive di una rappresentazione edge list. Le collezioni $V$ ed $E$ sono rappresentate come doubly linked list.

\begin{itemize}[nosep]
    \item Oggetto \textbf{Vertex}: rappresenta un vertice del grafo. Mantiene un riferimento al suo elemento (ad esempio, una stringa o un numero) e un riferimento alla sua posizione nella lista $V$ del grafo.
    \item Oggetto \textbf{Edge}: rappresenta un arco del grafo. Mantiene un riferimento al suo elemento (ad esempio, un peso o un'etichetta) e riferimenti ai due vertici estremi dell'arco. Inoltre, mantiene un riferimento alla sua posizione nella lista $E$ del grafo.
\end{itemize}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.8\textwidth]{immagini/Graphs/summary_edgeList.png}
    \caption{Riepilogo tempi di esecuzione ADT Grafo con rappresentazione Edge List.}
    \label{fig:summary_edgeList}
\end{figure}




\clearpage
\section{Rappresentazione mediante Adjacency List}
Diversamente dall'edge list, l'\emph{adjacency list} è una rappresentazione di un grafo che organizza gli archi in modo più strutturato, raggruppandoli per vertice. Ciascun vertice mantiene una collezione separata di archi incidenti, consentendo un accesso più efficiente agli archi associati a un particolare vertice. Più di preciso, ogni vertice $v$ del grafo mantiene una collezione $I(v)$, chiamata \emph{incidence collection} di $v$. (Nel caso di un grafo orientato, gli archi in uscita e in entrata possono essere memorizzati rispettivamente in due collezioni separate, $I_{out}(v)$ e $I_{in}(v)$.) Tradizionalmente, la collezione di incidenza $I(v)$ per un vertice $v$ è una lista, motivo per cui chiamiamo questo modo di rappresentare un grafo la struttura \emph{adjacency list}. 

\begin{figure}[!ht]
    \centering
    \includegraphics[width=1\textwidth]{immagini/Graphs/adj_list.png}
    \caption{(a) Un grafo non orientato $G$; (b) una rappresentazione schematica della struttura adjacency list per $G$. La collezione $V$ è la lista primaria di vertici, e ogni vertice ha una lista associata di archi incidenti. Sebbene non sia mostrato in figura, presumiamo che ogni arco del grafo sia rappresentato con un'istanza di Edge unica che mantiene riferimenti ai suoi vertici estremi.}
    \label{fig:adj_list}
\end{figure}

\noindent
Richiediamo che la struttura primaria per un adjacency list mantenga la collezione $V$ di vertici in modo tale da poter localizzare la struttura secondaria $I(v)$ per un dato vertice $v$ in tempo $O(1)$. Ciò potrebbe essere fatto utilizzando una positional list per rappresentare $V$, con ogni istanza di Vertex che mantiene un riferimento diretto alla sua collezione di incidenza $I(v)$. Se i vertici possono essere numerati in modo univoco da 0 a $n-1$, potremmo invece utilizzare una struttura primaria basata su array per accedere alle liste secondarie appropriate. Il vantaggio principale di un adjacency list è che la collezione $I(v)$ contiene esattamente quegli archi che dovrebbero essere riportati dal metodo \texttt{incident\_edges(v)}. Pertanto, possiamo implementare questo metodo iterando sugli archi di $I(v)$ in tempo $O(\text{deg}(v))$, dove $\text{deg}(v)$ è il grado del vertice $v$. Questo è il miglior risultato possibile per qualsiasi rappresentazione di grafo, poiché ci sono $\text{deg}(v)$ archi da riportare.

\clearpage
\noindent
L'utilizzo primario di questa rappresentazione riguarda i \textbf{grafi sparsi} \footnote
{Un \textbf{grafo sparso} è un grafo che ha un numero di archi (collegamenti) significativamente inferiore rispetto al numero massimo possibile, ovvero quando il numero di archi \(m\) è dell'ordine di \(O(n)\) (lineare) rispetto al numero di vertici \(n\), mentre un \textbf{grafo denso} ha \(m\approx O(n^{2})\) (quadratico). In pratica, i grafi sparsi hanno poche connessioni tra i nodi, rendendo le rappresentazioni come le liste di adiacenza più efficienti in termini di spazio rispetto alle matrici di adiacenza.}, 
tipici di reti reali (web, social network, mappe stradali), dove la maggior parte delle coppie di nodi non è collegata. Risulta inoltre ottimale per algoritmi che richiedono l'esplorazione sistematica dei vicini di un nodo. Lo svantaggio riguarda la verifica dell'esistenza di uno specifico arco tra due nodi: tale operazione non è istantanea, ma richiede una ricerca all'interno della collezione di adiacenza del vertice, con un tempo di esecuzione che cresce all'aumentare del numero di vicini del nodo stesso.

\vspace{1\baselineskip}
\begin{figure}[!ht]
    \centering
    \includegraphics[width=1\textwidth]{immagini/Graphs/summary_adjList.png}
    \caption{Riepilogo tempi di esecuzione ADT Grafo con rappresentazione Adjacency List.}
    \label{fig:summary_adjList}
\end{figure}


\clearpage
\section{Rappresentazione mediante Adjacency Map}
In una rappresentazione di tipo adjacency list, assumiamo che la struttura dati secondaria utilizzata per la adjacency list sia una linked list non ordinata. Tale collezione $I(v)$ utilizza uno spazio proporzionale a $O(\text{deg}(v))$, consente di aggiungere o rimuovere un arco in tempo $O(1)$ e consente di iterare su tutti gli archi incidenti al vertice $v$ in tempo $O(\text{deg}(v))$. Tuttavia, la migliore implementazione del metodo \texttt{get\_edge(u,v)} richiede un tempo di $O(\min(\text{deg}(u),\text{deg}(v)))$, poiché dobbiamo cercare all'interno di $I(u)$ o $I(v)$. Possiamo migliorare le prestazioni utilizzando una mappa basata su hash per implementare $I(v)$ per ogni vertice $v$. In particolare, lasciamo che l'estremo opposto di ogni arco incidente serva come chiave nella mappa, con la struttura dell'arco che funge da valore. Chiamiamo tale rappresentazione del grafo una \emph{adjacency map}. L'uso dello spazio per un adjacency map rimane $O(n+m)$, poiché $I(v)$ utilizza uno spazio $O(\text{deg}(v))$ per ogni vertice $v$, come nell'adjacency list. Il vantaggio dell'adjacency map, rispetto all'adjacency list, è che il metodo \texttt{get\_edge(u,v)} può essere implementato in tempo atteso $O(1)$ cercando il vertice $u$ come chiave in $I(v)$, o viceversa. Ciò fornisce un probabile miglioramento rispetto all'adjacency list, pur mantenendo il limite nel caso peggiore di $O(\min(\text{deg}(u),\text{deg}(v)))$. Nel confrontare le prestazioni dell'adjacency map con altre rappresentazioni, scopriamo che esso raggiunge essenzialmente tempi di esecuzione ottimali per tutti i metodi, rendendolo un'ottima scelta in generale come rappresentazione del grafo.



\begin{figure}[!ht]
    \centering
    \includegraphics[width=1\textwidth]{immagini/Graphs/adj_map.png}
    \caption{(a) un grafo non orientato $G$; (b) una rappresentazione schematica della struttura adjacency map per $G$. Ogni vertice mantiene una mappa secondaria in cui i vertici adiacenti fungono da chiavi, con gli archi di collegamento come valori associati. Sebbene non sia rappresentato come tale, presumiamo che esista un'istanza Edge unica per ogni arco del grafo, e che essa mantenga riferimenti ai suoi vertici estremi.}
    \label{fig:adj_map}
\end{figure}


\clearpage
\noindent
Questa struttura è frequentemente adottata in contesti che richiedono alta dinamicità e prestazioni bilanciate, come nelle librerie di manipolazione grafi general-purpose. Il vantaggio distintivo è l'utilizzo di una struttura di hashing per i collegamenti uscenti, che permette di accedere a uno specifico arco e di verificarne l'esistenza con un tempo atteso costante $O(1)$, pur mantenendo un consumo di memoria lineare rispetto al contenuto del grafo. Ciò facilita operazioni veloci di inserimento e rimozione degli archi. Di contro, la gestione interna delle tabelle hash introduce un certo \textit{overhead} di memoria e complessità computazionale per la gestione delle collisioni, rendendo la struttura leggermente più pesante per grafi di dimensioni molto ridotte o banali.

\vspace{1\baselineskip}
\begin{figure}[!ht]
    \centering
    \includegraphics[width=1\textwidth]{immagini/Graphs/summary_adjMap.png}
    \caption{Riepilogo tempi di esecuzione ADT Grafo con rappresentazione Adjacency Map.}
    \label{fig:summary_adjMap}
\end{figure}


\clearpage
\section{Rappresentazione mediante Adjacency Matrix}
La struttura \emph{adjacency matrix} per un grafo $G$ arricchisce la struttura edge list con una matrice $A$, che ci consente di localizzare un arco tra una data coppia di vertici in tempo costante nel caso peggiore. Nella rappresentazione adjacency matrix, consideriamo i vertici come gli interi nell'insieme $\{0,1, \ldots, n-1\}$ e gli archi come coppie di tali interi. Ciò ci consente di memorizzare riferimenti agli archi nelle celle di un array bidimensionale $n \times n$ $A$. In particolare, la cella $A[i, j]$ contiene un riferimento all'arco $(u,v)$, se esiste, dove $u$ è il vertice con indice $i$ e $v$ è il vertice con indice $j$. Se non esiste tale arco, allora $A[i, j] = \text{None}$. Notiamo che l'array $A$ è simmetrico se il grafo $G$ è non orientato, poiché $A[i, j] = A[j,i]$ per tutte le coppie $i$ e $j$. Il vantaggio più significativo di una matrice di adiacenza è che qualsiasi arco $(u,v)$ può essere visitato in tempo $O(1)$. Tuttavia, diverse operazioni sono meno efficienti con una matrice di adiacenza. Ad esempio, per trovare gli archi incidenti al vertice $v$, dobbiamo presumibilmente esaminare tutte le $n$ voci nella riga associata a $v$; ricordiamo che un adjacency list o map può localizzare quegli archi in tempo ottimale $O(\text{deg}(v))$. Aggiungere o rimuovere vertici da un grafo è problematico, poiché la matrice deve essere ridimensionata. Inoltre, l'uso dello spazio $O(n^2)$ di una matrice di adiacenza è tipicamente molto peggiore rispetto allo spazio $O(n+m)$ richiesto dalle altre rappresentazioni. Sebbene, nel caso peggiore, il numero di archi in un grafo denso sia proporzionale a $n^2$, la maggior parte dei grafi del mondo reale sono sparsi. In tali casi, l'uso di una matrice di adiacenza è inefficiente. Tuttavia, se un grafo è denso, le costanti di proporzionalità di una matrice di adiacenza possono essere più piccole rispetto a quelle di una lista o mappa di adiacenza. Infatti, se gli archi non hanno dati ausiliari, una matrice di adiacenza booleana può utilizzare un bit per ogni slot di arco, in modo tale che $A[i, j] = \text{True}$ se e solo se l'arco associato $(u,v)$ esiste.



\begin{figure}[!ht]
    \centering
    \includegraphics[width=1\textwidth]{immagini/Graphs/adj_matrix.png}
    \caption{(a) un grafo non orientato $G$; (b) una rappresentazione schematica della struttura di matrice di adiacenza per $G$, in cui $n$ vertici sono mappati agli indici da $0$ a $n-1$. Sebbene non sia mostrato in figura, presumiamo che esista un'istanza Edge unica per ogni arco, e che essa mantenga riferimenti ai suoi vertici estremi. Presumiamo inoltre che esista una lista secondaria di archi (non illustrata), per consentire al metodo \texttt{edges()} di funzionare in tempo $O(m)$, per un grafo con $m$ archi.}
    \label{fig:adj_matrix}
\end{figure}


\clearpage
\noindent
Questa struttura è indicata principalmente per la gestione di \textbf{grafi densi} o di dimensioni contenute e statiche, dove il numero di archi è elevato rispetto ai vertici. Il suo vantaggio fondamentale risiede nell'accesso immediato ai dati: verificare l'esistenza di un collegamento tra due nodi specifici avviene in tempo costante $O(1)$ tramite indirizzamento diretto degli indici. Tuttavia, questa rappresentazione impone un utilizzo della memoria quadratico $O(n^2)$ indipendentemente dal numero reale di archi, comportando un significativo spreco di spazio nei casi in cui i collegamenti siano scarsi. Inoltre, le operazioni di ridimensionamento del grafo, come l'aggiunta o la rimozione di vertici, risultano computazionalmente onerose poiché richiedono la riallocazione dell'intera struttura dati.

\vspace{1\baselineskip}
\begin{figure}[!ht]
    \centering
    \includegraphics[width=1\textwidth]{immagini/Graphs/summary_adjMatrix.png}
    \caption{Riepilogo tempi di esecuzione ADT Grafo con rappresentazione Adjacency Matrix.}
    \label{fig:summary_adjMatrix}
\end{figure}


\clearpage
\section{Implementazione Python (Adjacency Map)}
In questa sezione, forniamo un'implementazione dell'ADT Grafo. La nostra implementazione supporterà grafi orientati o non orientati, ma per facilità di spiegazione, la descriviamo prima nel contesto di un grafo non orientato. 

Utilizziamo una variante della rappresentazione \textbf{adjacency map}. Per ogni vertice $v$, utilizziamo un dizionario Python per rappresentare la mappa di incidenza secondaria $I(v)$. Tuttavia, non manteniamo esplicitamente le liste $V$ ed $E$, come originariamente descritto nella rappresentazione edge list. La lista $V$ è sostituita da un dizionario di primo livello $D$ che mappa ogni vertice $v$ alla sua mappa di incidenza $I(v)$; si noti che possiamo iterare su tutti i vertici generando l'insieme delle chiavi per il dizionario $D$. Utilizzando tale dizionario $D$ per mappare i vertici alle mappe di incidenza secondarie, non è necessario mantenere riferimenti a tali mappe di incidenza come parte delle strutture dei vertici. Inoltre, un vertice non ha bisogno di mantenere esplicitamente un riferimento alla sua posizione in $D$, poiché può essere determinato in tempo atteso $O(1)$. Ciò semplifica notevolmente la nostra implementazione. Tuttavia, una conseguenza del nostro design è che alcuni dei limiti di tempo di esecuzione nel caso peggiore per le operazioni dell'ADT grafo, dati nella Tabella \ref{fig:adt_graph}, \textbf{diventano limiti attesi}. Piuttosto che mantenere la lista $E$, ci accontentiamo di prendere l'unione degli archi trovati nelle varie mappe di incidenza; tecnicamente, ciò richiede un tempo $O(n+m)$ anziché strettamente $O(m)$, poiché il dizionario $D$ ha $n$ chiavi, anche se alcune mappe di incidenza sono vuote. 

\vspace{1\baselineskip}
\noindent
Da notare che abbiamo i metodi \texttt{\_\_hash\_\_} per entrambe le classi \emph{Vertex} e \emph{Edge} in modo che tali istanze possano essere utilizzate come chiavi negli insiemi e nei dizionari basati su hash di Python. I grafi sono non orientati per impostazione predefinita, ma possono essere dichiarati come orientati con un parametro opzionale al costruttore.

Internamente, gestiamo il caso orientato avendo due diverse istanze di dizionario di primo livello, \texttt{\_outgoing} e \texttt{\_incoming}, in modo tale che \texttt{outgoing[v]} mappi a un altro dizionario che rappresenta $I_{out}(v)$, e \texttt{incoming[v]} mappi a una rappresentazione di $I_{in}(v)$. Per unificare il nostro trattamento dei grafi orientati e non orientati, continuiamo a utilizzare gli identificatori \texttt{\_outgoing} e \texttt{\_incoming} nel caso non orientato, ma come alias dello stesso dizionario. Per comodità, definiamo un'utilità denominata \texttt{is\_directed} per consentirci di distinguere tra i due casi. 

Per i metodi \texttt{degree} e \texttt{incident\_edges}, che accettano ciascuno un parametro opzionale per differenziare tra le orientazioni in uscita e in entrata, scegliamo la mappa appropriata prima di procedere. Per il metodo \texttt{insert\_vertex}, inizializziamo sempre \texttt{outgoing[v]} a un dizionario vuoto per il nuovo vertice $v$. Nel caso orientato, inizializziamo indipendentemente anche \texttt{incoming[v]}. Per il caso non orientato, tale passaggio non è necessario poiché \texttt{\_outgoing} e \texttt{\_incoming} sono alias.




\clearpage

\begin{lstlisting}[
    language=Python,
    caption={Classi Vertex ed Edge (da annidare all'interno della classe Graph).},
    captionpos=b,
    label={lst:Vertex},
]
    #------------------------- nested Vertex class -------------------------
    class Vertex:
        """Lightweight vertex structure for a graph."""
        __slots__ = '_element'

        def __init__(self, x):
            """Do not call constructor directly. Use Graph's insert_vertex(x)."""
            self._element = x

        def element(self):
            """Return element associated with this vertex."""
            return self._element

        def __hash__(self):    # will allow vertex to be a map/set key
            return hash(id(self))



    #------------------------- nested Edge class -------------------------
    class Edge:
        """Lightweight edge structure for a graph."""
        __slots__ = '_origin', '_destination', '_element'

        def __init__(self, u, v, x):
            """Do not call constructor directly. Use Graph's insert_edge(u,v,x)."""
            self._origin = u
            self._destination = v
            self._element = x

        def endpoints(self):
            """Return (u,v) tuple for vertices u and v."""
            return (self._origin, self._destination)

        def opposite(self, v):
            """Return the vertex that is opposite v on this edge."""
            return self._destination if v is self._origin else self._origin

        def element(self):
            """Return element associated with this edge."""
            return self._element

        def __hash__(self):    # will allow edge to be a map/set key
            return hash((self._origin, self._destination))
\end{lstlisting}


\clearpage
\begin{lstlisting}[
    language=Python,
    caption={Classe Graph con rappresentazione Adjacency Map.},
    captionpos=b,
    label={lst:Graph},
]
class Graph:
    """Representation of a simple graph using an adjacency map."""

    def __init__(self, directed=False):
        """Create an empty graph (undirected, by default).

        Graph is directed if optional parameter is set to True.
        """
        self._outgoing = {}
        # only create second map for directed graph; use alias for undirected
        self._incoming = {} if directed else self._outgoing

    def is_directed(self):
        """Return True if this is a directed graph; False if undirected.

        Property is based on the original declaration of the graph, not its contents.
        """
        return self._incoming is not self._outgoing # directed if maps are distinct

    def vertex_count(self):
        """Return the number of vertices in the graph."""
        return len(self._outgoing)

    def vertices(self):
        """Return an iteration of all vertices of the graph."""
        return self._outgoing.keys()

    def edge_count(self):
        """Return the number of edges in the graph."""
        total = sum(len(self._outgoing[v]) for v in self._outgoing)
        # for undirected graphs, make sure not to double-count edges
        return total if self.is_directed() else total // 2

    def edges(self):
        """Return a set of all edges of the graph."""
        result = set()       # avoid double-reporting edges of undirected graph
        for secondary_map in self._outgoing.values():
            result.update(secondary_map.values()) # add edges to resulting set
        return result

    def get_edge(self, u, v):
        """Return the edge from u to v, or None if not adjacent."""
        return self._outgoing[u].get(v) # returns None if v not adjacent


    def degree(self, v, outgoing=True):
        """Return number of (outgoing) edges incident to vertex v in the graph.

        If graph is directed, optional parameter used to count incoming edges.
        """
        adj = self._outgoing if outgoing else self._incoming
        return len(adj[v])

    def incident_edges(self, v, outgoing=True):
        """Return all (outgoing) edges incident to vertex v in the graph.

        If graph is directed, optional parameter used to request incoming edges.
        """
        adj = self._outgoing if outgoing else self._incoming
        for edge in adj[v].values():
            yield edge

    def insert_vertex(self, x=None):
        """Insert and return a new Vertex with element x."""
        v = self.Vertex(x)
        self._outgoing[v] = {}
        if self.is_directed():
            self._incoming[v] = {} # need distinct map for incoming edges
        return v

    def insert_edge(self, u, v, x=None):
        """Insert and return a new Edge from u to v with auxiliary element x."""
        e = self.Edge(u, v, x)
        self._outgoing[u][v] = e
        self._incoming[v][u] = e
\end{lstlisting}

\clearpage
\begin{lstlisting}[
    language=Python,
    caption={Metodi di cancellazione per la classe Graph.},
    captionpos=b,
    label={lst:Graph_delete},
]
    def remove_vertex(self, v):
        """Remove vertex v and all its incident edges from the graph."""
        # Phase 1: Remove references to v from the adjacency maps of its neighbors.
        
        # For every neighbor w connected by an outgoing edge (v -> w),
        # remove the link back to v from w's incoming map.
        for w in list(self._outgoing[v]):
            del self._incoming[w][v]
            
        # If the graph is directed, we also need to handle incoming edges (u -> v).
        # We must remove the link to v from u's outgoing map.
        # (In an undirected graph, _incoming is _outgoing, so the loop above covered this).
        if self.is_directed():
            for u in list(self._incoming[v]):
                del self._outgoing[u][v]
        
        # Phase 2: Remove v from the graph's internal dictionaries.
        del self._outgoing[v]
        if self.is_directed():
            del self._incoming[v]


    def remove_edge(self, e):
        """Remove edge e from the graph."""
        u, v = e.endpoints()
        
        # Remove the edge from u's outgoing map
        del self._outgoing[u][v]
        
        # Remove the edge from v's incoming map
        del self._incoming[v][u]
\end{lstlisting}
