\chapter{Network Flow}
\label{cap:NetworkFlow}

I problemi di \textbf{Network Flow} sono una classe fondamentale di problemi che si presentano
nell'ambito del traffico in movimento in una una rete di trasporto.

Concettualmente, questa tipologia di problemi nasce nel contesto della gestione del traffico all'interno di una rete di trasporto fisica. L'intuizione di base è modellare lo spostamento di entità materiali (come veicoli, merci, pacchetti di rete) attraverso un sistema interconnesso soggetto a vincoli fisici. In questa analogia con le reti di trasporto:

\begin{itemize}
    \item \textbf{Gli archi (Edges):} rappresentano i canali di comunicazione o le strade che trasportano il traffico. Ogni arco possiede una capacità intrinseca che limita la quantità di flusso che può attraversarlo.
    \item \textbf{I nodi (Nodes):} fungono da giunzioni tra gli archi e operano come scambi (switches). Il loro compito è ricevere il flusso in entrata e ridistribuirlo sugli archi in uscita, rispettando solitamente un principio di conservazione (tutto ciò che entra deve uscire, salvo che per nodi speciali).
    \item \textbf{Il flusso (Flow):} è la quantità che deve essere spostata da specifici nodi di origine, detti \emph{sorgenti} (sources), verso nodi di destinazione, detti \emph{pozzi} (sinks).
\end{itemize}

\noindent
Sebbene l'origine intuitiva risieda nella logistica e nei trasporti, l'astrazione matematica fornita dalla teoria dei grafi permette di applicare i problemi di Network Flow a una vasta gamma di campi totalmente distinti.

\begin{itemize}
    \item \textbf{Reti di calcolatori:} instradamento dei pacchetti dati attraverso Internet massimizzando la banda passante.
    \item \textbf{Visione artificiale:} segmentazione delle immagini.
    \item \textbf{Scheduling e allocazione risorse:} assegnazione ottimale di compiti a macchine o persone.
    \item \textbf{Matching in grafi bipartiti:} accoppiamento massimo in contesti sociali o economici.
\end{itemize}


\clearpage
\section{Flow Network - Rete di flusso}
Una \textbf{Flow Network}\footnote{
    Con \emph{Flow Network} (tradotto come \textbf{Rete di flusso}) si indica l'oggetto combinatorio statico, ovvero il grafo $G$ dotato di capacità; con \emph{Network Flow} (tradotto come \textbf{Flusso} o \textbf{Flusso su rete}) si intende invece la classe di problemi di ottimizzazione associata.
} 
(\emph{rete di flusso}) è un grafo orientato $G = (V, E)$ che rispetta dei vincoli specifici:
\begin{itemize}
    \item Ogni arco $e \in E$ è associato con un peso non negativo che rappresenta la \textbf{capacità} $c_e$ dell'arco. La capacità indica la quantità massima di flusso che può attraversare l'arco.
    \item Esiste un nodo sorgente (\textbf{source}) $s \in V$ da cui il flusso ha origine.
    \item Esiste un nodo destinazione (o pozzo) (\textbf{sink}) $t \in V$ dove il flusso termina.
    \item Tutti gli altri nodi sono detti \textbf{nodi interni}. Tutto il flusso in entrata in un nodo interno deve essere uguale al flusso in uscita da quel nodo.
\end{itemize}

\vspace{1\baselineskip}
\noindent
Per il resto del capitolo, ci basiamo su delle assunzioni che ci aiuteranno a rendere più semplice la trattazione dei problemi di Network Flow, senza perdere di generalità.
\begin{itemize}
    \item La capacità $c_e$ di ogni arco $e$ è un numero intero (non negativo).
    \item Il nodo sorgente $s$ non ha archi entranti.
    \item Il nodo destinazione $t$ non ha archi uscenti.
    \item Ciascun nodo interno ha almeno un arco incidente.
\end{itemize}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.4\textwidth]{immagini/NetworkFlow/flow_network_ex.png}
    \caption{Esempio di Flow Network, con sorgente $s$ e destinazione $t$, e capacità associate agli archi.}
    \label{fig:flow_network_ex}
\end{figure}

\clearpage
\paragraph{Definizione di Flusso} 
Un \textbf{s-t Flow} in una Flow Network $G = (V, E)$ è una funzione
$ f: E \rightarrow R_{\geq 0} $ tale che:
\begin{itemize}
    \item \textbf{Capacity condition:} Per ogni arco $e \in E$, il flusso $f(e)$ non può superare la capacità $c_e$:
    \[
        0 \leq f(e) \leq c_e 
    \]
    \item \textbf{Conservation condition:} Per ogni nodo interno $v$ (quindi, esclusi $s$ e $t$), la somma del flusso in entrata deve essere uguale alla somma del flusso in uscita:
    \[
        \sum_{e \text{ into } v} f(e) = \sum _{e \text{ out of } v} f(e)
    \]
\end{itemize}

\noindent
Dove $\sum_{e \text{ into } v} f(e)$ somma il valore di flusso $f(e)$ su tutti gli archi che entrano nel nodo $v$, mentre $\sum _{e \text{ out of } v} f(e)$ è la somma dei valori di flusso su tutti gli archi che escono dal nodo $v$. 

La sorgente non ha archi in entrata, ma è permesso che abbia flusso in uscita; in altre parole, la sorgente può generare flusso. Simmetricamente, per la destinazione è permesso avere flusso in entrata, anche se non ha archi in uscita. 

\vspace{1\baselineskip}
\noindent
Il valore di un flusso $f$, denotato $v(f)$, è definito come la quantità di flusso generata dalla sorgente, ovvero la somma di tutti i flussi uscenti dalla sorgente:
\[
    v(f) = \sum_{e \text{ out of } s} f(e).
\]
Per compattezza, definiamo per ogni nodo $v \in V$ il flusso totale in entrata e in uscita come:
\[
    f^{in}(v) = \sum_{e \text{ into } v} f(e)
    \quad \text{e} \quad
    f^{out}(v) = \sum_{e \text{ out of } v} f(e)
\] 
Con questa terminologia, la \emph{conservation condition} per un nodo interno $v$ si riscrive semplicemente come $f^{in}(v) = f^{out}(v)$. Il valore del flusso diventa $v(f) = f^{out}(s)$. 

È utile estendere queste definizioni a un generico sottoinsieme di vertici $S \subseteq V$:
\[
    f^{in}(S) = \sum_{v \in S} f^{in}(v) 
    \quad \text{e} \quad 
    f^{out}(S) = \sum_{v \in S} f^{out}(v).
\]
Una proprietà fondamentale derivante dalla conservazione puntuale è che la conservazione vale anche per gli insiemi. Se $S$ è un insieme costituito interamente da nodi interni (cioè $s, t \notin S$), allora il flusso totale che entra nell'insieme deve essere uguale al flusso totale che ne esce:
\[
    f^{in}(S) = f^{out}(S)
\]
Questa proprietà ci assicura che il flusso non può accumularsi né disperdersi in nessuna sottoregione della rete che non contenga la sorgente o la destinazione.



\clearpage
\section{Maximum Flow Problem}
Data una rete di flusso $G = (V, E)$ con sorgente $s$ e destinazione $t$, un obiettivo naturale è determinare la massima capacità trasmissiva del sistema. Non ci limitiamo a cercare un instradamento qualsiasi, ma vogliamo sfruttare al massimo le capacità degli archi disponibili.

Il problema del \textbf{Maximum Flow} (Flusso Massimo) consiste nel trovare un flusso $f$ che massimizzi il valore totale del flusso in uscita dalla sorgente $v(f) = f^{out}(s)$.


\vspace{1\baselineskip}
\noindent
Supponiamo di voler trovare un flusso massimo in una rete. Scartata la programmazione dinamica, per la quale non esistono algoritmi noti in questo contesto, esploriamo un approccio greedy.

Partiamo da una situazione di flusso nullo: $f(e) = 0$ per ogni arco $e$. Sebbene questa configurazione rispetti i vincoli di capacità e conservazione, il valore del flusso è $0$. Proviamo quindi ad aumentare il valore di $f$ "spingendo" flusso lungo un cammino dalla sorgente $s$ alla destinazione $t$, fino ai limiti imposti dalle capacità degli archi.

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.9\textwidth]{immagini/NetworkFlow/greedy_flow_ex.png}
    \caption{(a) La rete della Figura \ref{fig:flow_network_ex}. (b) Un flusso valido di valore 20 che non permette ulteriori aumenti diretti. (c) L'aumento del flusso a 30 richiede di ridirigere il flusso esistente (linee tratteggiate).}
    \label{fig:greedy_flow_ex}
\end{figure}

\noindent
Facendo riferimento alla Figura~\ref{fig:greedy_flow_ex}, potremmo scegliere il cammino composto dagli archi $\{(s, u), (u, v), (v, t)\}$, portando il flusso su ciascuno di essi a $20$ e lasciando a $0$ gli altri.
Non siamo però all'ottimo (pari a $30$), pur trovandoci in uno stallo: non esistono altri cammini $s-t$ con capacità disponibile per un aumento diretto.

\noindent
Per sbloccare la situazione è necessario ridirigere il flusso esistente, come in Figura~\ref{fig:greedy_flow_ex}(c):

\begin{enumerate}
    \item Spingiamo $10$ unità di flusso lungo $(s, v)$; questo crea un eccesso di flusso entrante in $v$.
    \item Per compensare, "annulliamo" $10$ unità di flusso sull'arco $(u, v)$. Questo ripristina la conservazione in $v$, ma lascia troppo poco flusso in uscita da $u$.
    \item Infine, spingiamo $10$ unità lungo $(u, t)$, ripristinando la conservazione in $u$.
\end{enumerate}

\noindent
Questa operazione porta il flusso totale a $30$. L'intuizione fondamentale è che un algoritmo generale deve poter spingere flusso non solo in avanti (sfruttando la capacità residua), ma anche \textbf{indietro} (sugli archi già utilizzati). Tale meccanismo viene formalizzato introducendo il \textbf{Grafo Residuo}.


\clearpage
\subsection{Residual Graph}
Data una rete di flusso $G = (V, E)$, e un flusso $f$ su $G$. Definiamo il \textbf{grafo residuo} $G_f$ di $G$ rispetto a $f$ come segue.
\begin{itemize}
    \item L'insieme dei nodi di $G_f$ è lo stesso di quello di $G$.
    \item Per ogni arco $e = (u, v)$ di $G$ per cui $f(e) < c_e$, esistono $c_e - f(e)$ unità di capacità "residua" su cui possiamo provare a spingere flusso in avanti. Quindi includiamo l'arco $e = (u, v)$ in $G_f$, con una capacità di $c_e - f(e)$. Chiameremo questi archi \textbf{archi in avanti} (\emph{forward edges}).
    \item Per ogni arco $e = (u, v)$ di $G$ per cui $f(e) > 0$, esistono $f(e)$ unità di flusso che possiamo eventualmente "annullare" spingendo flusso all'indietro. Quindi includiamo l'arco $e' = (v, u)$ in $G_f$, con una capacità di $f(e)$. Si noti che $e'$ ha gli stessi estremi di $e$, ma la sua direzione è invertita; chiameremo questi archi \textbf{archi all'indietro} (\emph{backward edges}). 
\end{itemize}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=1\textwidth]{immagini/NetworkFlow/residual_graph_ex.png}
    \caption{(a) Il grafo $G$ con il cammino $s, u, v, t$ usato per spingere le prime 20 unità di flusso.
    (b) Il grafo residuo del flusso risultante $f$, con la capacità residua accanto a ogni arco. La linea tratteggiata è il nuovo cammino aumentante (augmenting path). (c) Il grafo residuo dopo aver spinto ulteriori 10 unità di flusso lungo il nuovo cammino aumentante $s, v, u, t$.}
    \label{fig:residual_graph_ex}
\end{figure}

\noindent
Da notare che ciascun arco $e$ in $G$ può generare uno o due archi in $G_f$. Se $0 < f(e) < c_e$ risulta che sia un arco in avanti sia uno all'indietro sono inclusi in $G_f$. Questo comporta quindi che $G_f$ ha al più il doppio degli archi di $G$. 

A volte ci riferiremo alla capacità di un arco nel grafo residuo come \textbf{capacità residua}, per distinguere dalla capacità dell'arco corrispondente nella rete di flusso originale $G$.


\clearpage
\subsection{Augmenting Path}
Sia $P$ un cammino semplice da $s$ a $t$ in $G_f$ (cioè, $P$ non visita alcun nodo più di una volta). Definiamo \texttt{bottleneck(P, f)} come la \textbf{capacità residua minima} di qualsiasi arco su $P$, rispetto al flusso $f$.
Di seguito definiamo l'operazione \texttt{augment(f, P)}, che produce un nuovo flusso $f'$ in $G$.

\vspace{1\baselineskip}
\hrule
\begin{verbatim}
Input: P è un cammino semplice s-t in G_f
       f è un flusso in G
Output: f' è un flusso in G ottenuto aumentando f lungo P
1.  Algorithm augment(P, f):
2.      let b = bottleneck(P, f)
3.      for each edge e = (u, v) in P do  # P composto da archi di G_f
4.          if e is a forward edge then
5.              f'(e) = f(e) + b
6.          else
7.              f'(e) = f(e) - b
8.      return f'  
\end{verbatim}
\hrule 
\vspace{1\baselineskip}

\noindent
È stato proprio per poter eseguire questa operazione che abbiamo definito il grafo residuo; per riflettere l'importanza di \texttt{augment}, si indica spesso come \textbf{cammino aumentante} (\emph{augmenting path}) qualsiasi cammino $s-t$ nel grafo residuo.
Il risultato di \texttt{augment(f , P)} è un nuovo flusso $f'$ in $G$, ottenuto aumentando e diminuendo i valori di flusso sugli archi di $P$. 

\paragraph{Proposizione}
Sia $G = (V, E)$ una rete di flusso, e sia $f$ un flusso in $G$. Sia $P$ un cammino semplice $s-t$ in $G_f$. Allora l'output $f'$ di \texttt{augment(f , P)} è un flusso in $G$.

\paragraph{Dimostrazione}
Per dimostrare che $f'$ sia effettivamente un flusso, dobbiamo verificare che $f'$ soddisfi le capacity conditions e conservation conditions.

Iniziamo con la capacity condition.
\begin{itemize}
    \item \textbf{Arco in avanti:} Se $(u, v)$ è un arco in avanti in $G_f$, esso corrisponde all'arco $e = (u, v) \in E$, con capacità residua $c_f(e) = c_e - f(e)$.
    Il nuovo flusso sarà $f'(e) = f(e) + b$. Poiché $b \leq c_e - f(e)$, otteniamo:
    \[
        0 \leq f(e) \leq f'(e) = f(e) + b \leq f(e) + (c_e - f(e)) = c_e
    \]
    La capacity condition è verificata.

    \item \textbf{Arco all'indietro:} Se $(u, v)$ è un arco all'indietro in $G_f$, esso deriva dall'arco fisico $e = (v, u) \in E$, con capacità residua $c_f(e) = f(e)$.
    Poiché stiamo diminuendo il flusso sull'arco originale di $b$, abbiamo:
    \[
        c_e \geq f(e) \geq f'(e) = f(e) - b \geq f(e) - f(e) = 0
    \]
    La capacity condition è verificata anche in questo caso.
\end{itemize}
\noindent
In entrambi i casi, il nuovo flusso rispetta i limiti imposti dalle capacità $c_e$ e la non negatività.

Passiamo alla conservation condition.
Dobbiamo verificare che per ogni nodo interno $v$ appartenente al cammino $P$, la variazione della quantità di flusso in entrata in $v$ è la stessa della variazione della quantità di flusso in uscita da $v$.\footnote{
    Sulle slide del corso, il continuo di questa seconda parte della dimostrazione non è presente; le slide si limitano a enunciare che \texttt{augment} preserva la conservazione del flusso, senza fornire ulteriori dettagli.
} Siano $u$ il nodo precedente e $w$ il nodo successivo a $v$ lungo il cammino $P$ in $G_f$ (ovvero $u \to v \to w$).
Poiché $f$ soddisfa la conservazione, è sufficiente mostrare che la variazione di flusso apportata da \texttt{augment} preserva l'equilibrio tra flusso entrante e uscente. Distinguiamo i quattro casi possibili in base alla tipologia degli archi $(u, v)$ e $(v, w)$ nel grafo residuo:

\begin{itemize}
    \item \textbf{Forward $\to$ Forward:} Entrambi gli archi sono in avanti.
    In $G$ esistono gli archi fisici $e_1 = (u, v)$ ed $e_2 = (v, w)$.
    L'operazione aumenta il flusso su entrambi di $b$. Di conseguenza, il flusso entrante in $v$ aumenta di $b$ (da $e_1$) e quello uscente aumenta di $b$ (su $e_2$). L'equilibrio è mantenuto.

    \item \textbf{Backward $\to$ Backward:} Entrambi gli archi sono all'indietro.
    In $G$ esistono gli archi fisici $e_1 = (v, u)$ ed $e_2 = (w, v)$.
    L'operazione diminuisce il flusso su entrambi di $b$.
    Diminuendo il flusso su $e_1$ (uscente da $v$), riduciamo l'uscita totale di $b$. Diminuendo il flusso su $e_2$ (entrante in $v$), riduciamo l'entrata totale di $b$.
    Poiché entrata e uscita diminuiscono della stessa quantità, l'equilibrio è mantenuto.

    \item \textbf{Forward $\to$ Backward:} L'arco entrante è in avanti, quello uscente è all'indietro.
    In $G$ esistono gli archi fisici $e_1 = (u, v)$ ed $e_2 = (w, v)$.
    Aumentiamo il flusso su $e_1$ di $b$ (aumento dell'entrata).
    Diminuiamo il flusso su $e_2$ di $b$ (diminuzione dell'entrata).
    La variazione netta del flusso entrante è $+b - b = 0$, mentre il flusso uscente resta invariato. L'equilibrio è mantenuto.

    \item \textbf{Backward $\to$ Forward:} L'arco entrante è all'indietro, quello uscente è in avanti.
    In $G$ esistono gli archi fisici $e_1 = (v, u)$ ed $e_2 = (v, w)$.
    Diminuiamo il flusso su $e_1$ di $b$ (diminuzione dell'uscita).
    Aumentiamo il flusso su $e_2$ di $b$ (aumento dell'uscita).
    La variazione netta del flusso uscente è $-b + b = 0$, mentre il flusso entrante resta invariato. L'equilibrio è mantenuto.
\end{itemize}
\noindent
In tutti i casi, la proprietà di conservazione del flusso continua a valere per $f'$.

\clearpage
\subsection{MaxFlow Algorithm}
Questa operazioni di \emph{augmentation} ci permette di modificare un flusso esistente spingendo ulteriore flusso lungo cammini aumentanti nel grafo residuo.
Ripetendo questa procedura, possiamo incrementare il valore del flusso fino a quando non esistono più cammini aumentanti nel grafo residuo. A questo punto, il flusso ottenuto è massimo.

Di seguito è riportato lo pseudocodice dell'algoritmo \textbf{MaxFlow}, o algoritmo di Ford-Fulkerson.

\vspace{1\baselineskip}
\hrule
\begin{alltt}
1. \textbf{Algorithm} Max-Flow(\(G\)):
2.     Initialize \(f(e) = 0\) for all edges \(e\) in \(G\)
3.     Construct the residual graph \(G\sb{f}\)
4.     \textbf{while} there is an \(s\)-\(t\) path in \(G\sb{f}\) \textbf{do}
5.         Let \(P\) be a simple \(s\)-\(t\) path in \(G\sb{f}\)
6.         \(f' = \text{Augment}(P, f)\)
7.         \(f = f'\)
8.         \(G\sb{f} = G\sb{f'}\)
9.     \textbf{return} \(f\)
\end{alltt}
\hrule 
\vspace{1\baselineskip}

\noindent
L'algoritmo MaxFlow risulta piuttosto intuitivo. Ciò che può sembrare meno ovvio è capire se il ciclo \texttt{While} termina, e se il flusso restituito sia effettivamente massimo.

Per analizzare la correttezza e la terminazione dell'algoritmo, è necessario richiamare un'assunzione già fatta sulla natura delle capacità, che ora ripetiamo: assumiamo inizialmente che tutte le capacità degli archi $c_e$ siano numeri interi.

Sotto questa ipotesi, dimostriamo inizialmente che l'algoritmo Max-Flow termina, e ne analizziamo la complessità; solo in un secondo momento dimostreremo che tale algoritmo produce un flusso massimo. La dimostrazione si basa su due proprietà fondamentali che valgono a ogni iterazione del ciclo \texttt{while}.

\paragraph{Proprietà 1: Flussi e capacità residue come numeri interi}
Possiamo facilmente osservare che in ogni fase intermedia dell'algoritmo i valori del flusso $f(e)$ e le capacità residue in $G_f$ rimangono interi.
\begin{itemize}
    \item Prima del ciclo \texttt{while}, il flusso è inizializzato a $0$ ovunque, e le capacità residue coincidono con le capacità originali (che sono intere per ipotesi).
    \item Ad ogni step, quando troviamo un cammino aumentante $P$, calcoliamo il valore $b = \texttt{bottleneck}(P, f)$. Essendo $b$ il minimo tra le capacità residue degli archi di $P$ (che sono intere), anche $b$ sarà un intero. Di conseguenza, anche le nuove capacità residue nel passo successivo rimarranno intere.
\end{itemize}

\paragraph{Proprietà 2: Il valore del flusso cresce strettamente}
Dimostriamo che ad ogni iterazione il valore del flusso aumenta di almeno 1 unità: $v(f') \geq v(f) + 1$.
Consideriamo il primo arco $e$ del cammino aumentante $P$. Poiché $P$ inizia da $s$, $e$ deve essere un arco uscente dalla sorgente in direzione del grafo residuo. Per definizione di grafo residuo, un arco esiste in $P$ solo se la sua capacità residua è strettamente positiva: $c_f(e) > 0$.
Poiché le capacità sono intere e $P$ è un cammino valido in $G_f$, la capacità residua minima $b$ deve essere almeno $1$ ($b \geq 1$).
L'operazione \texttt{Augment} aumenta il flusso su questo arco di $b$, incrementando di conseguenza il flusso totale uscente da $s$. Pertanto:
\[
    v(f') = f'^{out}(s) = f^{out}(s) + b \geq f^{out}(s) + 1 = v(f) + 1 
\]

\paragraph{Terminazione}
Per provare che l'algoritmo termina, definiamo $C$ come la somma totale delle capacità degli archi uscenti dalla sorgente $s$:
\[ C = \sum_{e \text{ out of s }} c_e \]
Il valore di un qualsiasi flusso ammissibile non può mai superare la capacità fisica totale degli archi che lasciano la sorgente, quindi $v(f) \leq C$.
Poiché partiamo da un flusso nullo ($v(f)=0$) e ad ogni iterazione il valore aumenta di almeno un intero ($v(f_{i+1}) \geq v(f_i) + 1$), l'algoritmo non può eseguire più di $C$ iterazioni. Questo garantisce la terminazione.

\paragraph{Analisi della Complessità}
Valutiamo ora il costo computazionale. Il tempo totale è dato dal numero di iterazioni moltiplicato per il costo di una singola iterazione.

\begin{enumerate}
    \item \textbf{Costo per iterazione:} In ogni passo dobbiamo trovare un cammino $s-t$ nel grafo residuo $G_f$ e aggiornare i flussi.
    \begin{itemize}[nosep]
        \item La ricerca del cammino può essere effettuata con una visita in ampiezza (BFS) o profondità (DFS).\footnote{
            In pratica si preferisce la BFS perché, trovando sempre il cammino più breve in termini di numero di archi, evita i casi patologici in cui il flusso viene incrementato di quantità minime, garantendo così una convergenza molto più rapida (polinomiale) rispetto a una scelta arbitraria o basata su DFS.
        } Questo richiede tempo $O(m + n)$.
        \item L'aggiornamento delle capacità e dei flussi lungo il cammino richiede tempo proporzionale alla lunghezza del cammino stesso, che è al più $O(n)$.
    \end{itemize}
    Pertanto, ogni iterazione costa $O(m)$ se si assume che il grafo sia connesso ($m \geq n - 1$).

    \item \textbf{Numero di iterazioni:} Come dimostrato, il numero massimo di aumenti è limitato da $C$.
\end{enumerate}
\noindent
Combinando questi fattori, la complessità temporale dell'algoritmo\footnote{ 
    È importante notare che la complessità $O(m C)$ non è polinomiale in senso stretto, ma \emph{pseudo-polinomiale}. La complessità non dipende solo dalla dimensione dell'input (numero di nodi e archi), ma anche dal valore numerico $C$. Se $C$ è grande rispetto alla dimensione del grafo, l'algoritmo può diventare inefficiente.
}
\footnote{
    Utilizzando tecniche più sofisticate per selezionare i cammini aumentanti, è possibile progettare algoritmi con complessità temporale $O(n^3)$, quindi con complessità polinomiale.
} 
Max-Flow è:
\[ O(m \cdot C) \]


\clearpage
\subsection{s-t Cuts}
Finora abbiamo dimostrato che l'algoritmo Max-Flow termina e produce un flusso valido. Rimane da dimostrare che il flusso restituito sia effettivamente massimo.

Per fare ciò, introduciamo il concetto di \textbf{s-t Cut} (taglio s-t) in una rete di flusso.

\paragraph{Definizione:} 
Un \textbf{s-t Cut} in una rete di flusso $G = (V, E)$ è una partizione dei nodi $V$ in due insiemi disgiunti $A$ e $B$ tali che $s \in A$ e $t \in B$. 
Indichiamo gli archi che attraversano il taglio, ovvero quelli che vanno da un nodo in $A$ a un nodo in $B$, come:
\[
    cut(A, B) = \{(u, v) \in E \mid u \in A, v \in B\}
\]
La \textbf{capacità di un taglio} $(A, B)$, che indichiamo con $c(A, B)$, è definita come la somma delle capacità degli archi che vanno da $A$ a $B$:
\[
    c(A, B) = \sum_{e \text{ out of } A} c_e
\]

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.6\textwidth]{immagini/NetworkFlow/st_cut.png}
    \caption{Esempio di s-t Cut in una rete di flusso.}
    \label{fig:st_cut}
\end{figure}

\vspace{2\baselineskip}
\noindent
In precedenza abbiamo visto come $C = \sum_{e \text{ out of } s} c_e$ fornisca già un limite superiore al valore di qualsiasi flusso, e si ha $v(f) \leq C$. Tuttavia, $C$ potrebbe essere una sovrastima enorme del valore massimo di un flusso in G, per cui a volte questo limite è utile, ma altre volte si rivela molto debole.

Fortunatamente, il concetto di s-t Cuts ci permette di ottenere un limite superiore più stretto e significativo per il valore di qualsiasi flusso in $G$.

\clearpage
\paragraph{Proposizione}
Sia $f$ un qualsiasi flusso in una rete di flusso $G = (V, E)$, e sia $(A, B)$ un qualsiasi s-t Cut in $G$. Allora: $v(f) = f^{out}(A) - f^{in}(A)$.

\paragraph{Dimostrazione}
Per definizione, il valore del flusso è $v(f) = f^{out}(s)$. Dalle nostre assunzioni inoltre sappiamo che $f^{in}(s) = 0$, poiché la sorgente $s$ non ha archi entranti e possiamo quindi scrivere: $v(f) = f^{out}(s) - f^{in}(s)$. Dal momento che ogni nodo $v$ in $A$ diverso da $s$ è un nodo interno, sappiamo che $f^{out}(v) - f^{in}(v) = 0$ per tutti questi nodi. Quindi:
\[
    v(f) = \sum_{v \in A} (f^{out}(v) - f^{in}(v)),
\]
dovuto al fatto che l'unico termine in questa somma che è diverso da zero è quello in cui $v$ è uguale a $s$.
Cerchiamo di riscrivere la somma a destra in un altro modo. Se un arco $e$ ha entrambe le estremità in $A$, allora $f(e)$ appare una volta nella somma con un segno "+" e una volta con un segno "-", e quindi questi due termini si cancellano a vicenda. Se $e$ ha solo la coda in $A$, allora $f(e)$ appare una sola volta nella somma, con un segno "+". Se $e$ ha solo la testa in $A$, allora $f(e)$ appare anche una sola volta nella somma, con un segno "-". Infine, se $e$ non ha nessuna delle due estremità in $A$, allora $f(e)$ non appare affatto nella somma. In vista di ciò, abbiamo:
\[
    \sum_{v \in A} (f^{out}(v) - f^{in}(v)) =
    \sum_{e \text{ out of } A} f(e) -
    \sum_{e \text{ into } A} f(e) = f^{out}(A) - f^{in}(A).
\]
Mettendo insieme queste due equazioni, otteniamo: $v(f) = f^{out}(A) - f^{in}(A)$.

\vspace{1\baselineskip}
\noindent
Utilizzando questa proposizione, possiamo ora dimostrare che il valore di qualsiasi flusso $f$ è limitato superiormente dalla capacità di qualsiasi s-t Cut $(A, B)$ in $G$. $\quad \blacksquare$

\paragraph{Proposizione}
Sia $f$ un qualsiasi flusso in una rete di flusso $G = (V, E)$, e sia $(A, B)$ un qualsiasi s-t Cut in $G$. Allora: $v(f) \leq c(A, B)$.

\paragraph{Dimostrazione}
\[
    v(f) = f^{out}(A) - f^{in}(A) 
        \leq f^{out}(A) 
        = \sum_{e \text{ out of } A} f(e) 
        \leq \sum_{e \text{ out of } A} c_e 
        = c(A, B)
\]
La prima uguaglianza è data dalla proposizione precedente. Passiamo dalla prima alla seconda disuguaglianza poiché $f^{in}(A) \geq 0$, e passiamo dalla terza alla quarta applicando le condizioni di capacità a ciascun termine della somma. $\quad \blacksquare$

\vspace{1\baselineskip}
\noindent
In sostanza, questa proposizione afferma che tutto il flusso che va dalla sorgente $s$ alla destinazione $t$ deve attraversare gli archi che compongono il taglio $cut(A, B)$ per passare da $A$ a $B$, e che al massimo $c(A, B)$ unità di flusso possono attraversare questi archi, dato che $c(A, B)$ è proprio la somma delle capacità di quegli archi.

\clearpage
\noindent
Abbiamo quindi stabilito un limite superiore: il valore di un qualsiasi flusso non può mai superare la capacità di un qualsiasi taglio.
Tuttavia, il nostro obiettivo è dimostrare che l'algoritmo Max-Flow restituisce effettivamente un flusso massimo. Per fare ciò, dobbiamo mostrare che esiste un taglio specifico la cui capacità è esattamente uguale al valore del flusso trovato dall'algoritmo.

\paragraph{Analisi alla terminazione dell'algoritmo}
Consideriamo lo stato dell'algoritmo Max-Flow nel momento in cui termina. La condizione di terminazione del ciclo \texttt{while} è che \textbf{non esistono più cammini aumentanti} (percorsi da $s$ a $t$) nel grafo residuo $G_f$.

Basandoci su questa proprietà, possiamo costruire una specifica partizione dei nodi $(A^*, B^*)$ definita come segue:
\begin{itemize}
    \item $A^* = \{v \in V \mid \exists \text{ un cammino da } s \text{ a } v \text{ in } G_f\}$ (l'insieme dei nodi raggiungibili dalla sorgente nel grafo residuo).
    \item $B^* = V \setminus A^*$ (l'insieme di tutti gli altri nodi, non raggiungibili da $s$ in $G_f$).
\end{itemize}

\noindent
Verifichiamo che $(A^*, B^*)$ sia effettivamente un \textbf{s-t Cut}:
\begin{enumerate}
    \item La sorgente $s$ è certamente in $A^*$.
    \item La destinazione $t$ deve trovarsi in $B^*$. Se $t$ fosse in $A^*$, significherebbe che esiste un cammino da $s$ a $t$ in $G_f$, ma questo contraddice la condizione di terminazione dell'algoritmo.
\end{enumerate}
Dunque, $(A^*, B^*)$ è un taglio valido.

\paragraph{Caratteristiche degli archi attraverso il taglio $(A^*, B^*)$}
Esaminiamo ora il flusso $f$ (quello calcolato dall'algoritmo al momento dell'arresto) sugli archi che attraversano questo specifico taglio.
Consideriamo un arco fisico $e = (u, v)$ nel grafo originale $G$:

\begin{figure}[!ht]
    \centering
    \includegraphics[width=1\textwidth]{immagini/NetworkFlow/min_cut_dem.png}
    \caption{Il taglio $(A^*, B^*)$ utilizzato nella dimostrazione.}
    \label{fig:min_cut_dem}
\end{figure}


\clearpage
\begin{enumerate}
    \item \textbf{Archi in avanti (da $A^*$ a $B^*$):}
    Sia $e = (u, v)$ un arco in $G$ per cui $u \in A^*$ e $v \in B^*$, come mostrato in Figura~\ref{fig:min_cut_dem}.
    Se l'arco non fosse saturo (cioè se $f(e) < c_e$), allora nel grafo residuo $G_f$ esisterebbe un arco in avanti $(u, v)$ con capacità residua positiva.
    Ma se esiste l'arco $(u, v)$ in $G_f$ e $u$ è raggiungibile da $s$ (poiché $u \in A^*$), allora anche $v$ sarebbe raggiungibile da $s$. Questo implicherebbe $v \in A^*$, contraddicendo l'ipotesi $v \in B^*$.\\
    \textbf{Conclusione:} Tutti gli archi che vanno da $A^*$ a $B^*$ devono essere saturi.
    \[ \forall e \text{ out of } A^* \implies f(e) = c_e \] 

    \item \textbf{Archi all'indietro (da $B^*$ a $A^*$):}
    Sia $e'$ = (u', v') un arco in $G$ per cui $u' \in B^*$ e $v' \in A^*$, come mostrato in Figura~\ref{fig:min_cut_dem}. Vogliamo ottenere che $f(e') = 0$. Se così non fosse, l'arco $e'$ genererebbe un arco all'indietro $e'' = (v', u')$ nel grafo residuo $G_f$.
    Poiché $v' \in A^*$, esiste un cammino da $s$ a $v'$ in $G_f$; aggiungendo l'arco all'indietro $e''$ a questo cammino, otterremmo un cammino da $s$ a $u'$ in $G_f$, il che contraddice l'ipotesi che $u' \in B^*$.\\
    \textbf{Conclusione:} Tutti gli archi che vanno da $B^*$ a $A^*$ devono avere flusso nullo.
    \[ \forall e \text{ into } A^* \implies f(e) = 0 \]
\end{enumerate}


\paragraph{Teorema Max-Flow Min-Cut}
Utilizzando le proprietà appena derivate, possiamo calcolare il valore del flusso $f$ attraverso il taglio $(A^*, B^*)$ usando il lemma precedente ($v(f) = f^{out}(A) - f^{in}(A)$):
\[
    v(f) = f^{out}(A^*) - f^{in}(A^*) = \sum_{e \text{ out of } A^*} f(e) - \sum_{e \text{ into } A^*} f(e)
\]
Sostituendo i valori trovati ($f(e) = c_e$ per gli archi uscenti e $f(e) = 0$ per gli archi entranti):
\[
    v(f) = \sum_{e \text{ out of } A^*} c_e - \sum_{e \text{ into } A^*} 0
\]

\[
    v(f) = \sum_{e \text{ out of } A^*} c_e = c(A^*, B^*)
\]
Abbiamo quindi trovato uno specifico taglio $(A^*, B^*)$ la cui capacità è esattamente uguale al valore del flusso $f$ calcolato dall'algoritmo.
Ricordando la disuguaglianza generale dimostrata in precedenza, secondo cui per \emph{qualsiasi} flusso $f'$ e \emph{qualsiasi} taglio $(A, B)$ vale sempre $v(f') \leq c(A, B)$, l'aver trovato un caso di uguaglianza ha due conseguenze immediate:

\begin{itemize}
    \item \textbf{$f$ è un flusso di valore massimo.} 
    Poiché il valore di nessun flusso può mai superare la capacità del taglio $(A^*, B^*)$, e il nostro flusso $f$ raggiunge esattamente tale capacità, è impossibile che esista un flusso con valore maggiore.
    
    \item \textbf{$(A^*, B^*)$ è un taglio di capacità minima.} 
    Poiché la capacità di nessun taglio può mai scendere al di sotto del valore del flusso $f$, e il nostro taglio $(A^*, B^*)$ ha capacità esattamente pari a $v(f)$, è impossibile che esista un taglio con capacità minore.
\end{itemize}


\clearpage
\noindent
Dal momento che l'algoritmo di Ford-Fulkerson termina quando non esistono più cammini aumentanti nel grafo residuo, e che abbiamo dimostrato che in questo caso il flusso calcolato è massimo, possiamo concludere l'algoritmo di Ford-Fulkerson restituisce la soluzione ottima.

Questo risultato ci porta al seguente teorema fondamentale nella teoria dei flussi di rete:

\vspace{1\baselineskip}
\noindent
\fbox{
    \parbox{\textwidth}{
        \centering
        \textbf{Max-Flow Min-Cut Theorem} \\
        In ogni rete di flusso, il valore del flusso massimo è uguale alla capacità del taglio minimo.
    }
}
\vspace{0.5\baselineskip}

\paragraph{Calcolo del Min-Cut}
Oltre a dimostrare l'ottimalità del flusso, questa costruzione ci fornisce un algoritmo efficiente per trovare il taglio minimo in una rete.
Dato un flusso massimo $f$ (calcolato ad esempio con l'algoritmo Max-Flow), possiamo trovare il taglio di capacità minima $(A^*, B^*)$ in tempo $O(m)$:
\begin{enumerate}
    \item Costruiamo il grafo residuo $G_f$.
    \item Eseguiamo una visita (BFS o DFS) partendo da $s$ in $G_f$ per identificare l'insieme $A^*$ di tutti i nodi raggiungibili.
    \item Poniamo $B^* = V \setminus A^*$.
    \item Il taglio $(A^*, B^*)$ è il taglio minimo cercato.
\end{enumerate}

\noindent
Possiamo vedere il problema del flusso massimo e quello del taglio minimo come due facce della stessa medaglia: il primo rappresenta il problema \textbf{primale}, mentre il secondo è il suo \textbf{duale}.
La forza di questo legame sta nel fatto che non abbiamo bisogno di due procedure separate. Nel momento esatto in cui risolviamo il problema primale (trovando il flusso massimo), otteniamo \textit{automaticamente} e a costo zero la soluzione per il problema duale. Questo è un grande vantaggio pratico, perché cercare direttamente il taglio minimo "da zero" sarebbe molto più complicato e meno intuitivo rispetto al calcolo del flusso.


\paragraph{L'algoritmo Max-Flow in presenza di capacità reali}
Per provare la correttezza dell'algoritmo Max-Flow, abbiamo fatto un'importante assunzione, e cioè che tutte le capacità degli archi siano numeri interi.
Questa ipotesi è cruciale per garantire la terminazione dell'algoritmo, poiché ci ha permesso di dimostrare che ad ogni iterazione il valore del bottleneck fosse almeno $1$, ovvero che il flusso aumenta di almeno $1$ unità, limitando così il numero totale di iterazioni a $C$ (la somma delle capacità uscenti da $s$).

In presenza di capacità reali, questa garanzia non vale più.
La nostra analisi funziona addirittura nel caso di numeri razionali, ma se ad esempio le capacità fossero numeri irrazionali l'algoritmo potrebbe incrementare il flusso di quantità sempre più piccole, avvicinandosi asintoticamente al valore massimo senza mai raggiungerlo esattamente, e quindi non terminerebbe mai. In questo caso, è comunque possibile dimostrare che l'algoritmo Max-Flow produce un flusso di valore massimo, ma la dimostrazione richiede tecniche più avanzate e non è trattata in questo corso.


\clearpage
\section{Il problema del Bipartite Matching}
Una delle applicazioni più importanti del problema del Maximum-Flow è la risoluzione del problema del Bipartite Matching (accoppiamento bipartito).

\paragraph{Definizione:} 
Un \textbf{grafo bipartito} $G = (V, E)$ è un grafo non orientato i cui nodi possono essere divisi in due insiemi disgiunti $X$ e $Y$, e si ha $V = X \cup Y$ e $X \cap Y = \emptyset$, con la proprietà che ogni arco $e \in E$ abbia un'estremità in $X$ e l'altra in $Y$. 

Un \textbf{matching} $M$ in $G$ è un sottoinsieme degli archi $M \subseteq E$ tale che ogni nodo appare in al più un arco in $M$.

Il \textbf{Bipartite Matching Problem} è quello di trovare un matching in $G$ di dimensione massima possibile.

\vspace{1\baselineskip}
\noindent
Esempi di applicazioni del Bipartite Matching includono l'assegnazione di compiti a lavoratori, la corrispondenza tra studenti e progetti, o l'abbinamento tra offerte e richieste in un mercato.

\paragraph{Algoritmo di Bipartite Matching}
Un algoritmo molto semplice per risolvere il Bipartite Matching Problem sfrutta l'algoritmo Max-Flow.
L'idea è di trasformare il grafo bipartito $G = (X \cup Y, E)$ in una rete di flusso $G' = (V', E')$ come segue:
\begin{enumerate}
    \item Orientiamo gli archi di $G$ da $X$ verso $Y$.
    \item Aggiungiamo una sorgente $s$ e colleghiamola a tutti i nodi in $X$.
    \item Aggiungiamo una destinazione $t$ e colleghiamo tutti i nodi in $Y$ a $t$.
    \item Assegniamo capacità $c_e = 1$ a tutti gli archi in $E'$.
    \item Calcoliamo un flusso massimo $f$ in $G'$ utilizzando l'algoritmo Max-Flow.
\end{enumerate}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=1\textwidth]{immagini/NetworkFlow/bipartite.png}
    \caption{Esempio di trasformazione di un grafo bipartito in una rete di flusso per risolvere il Bipartite Matching Problem.}
    \label{fig:bipartite_matching}
\end{figure}

\clearpage
\noindent
Per dimostrare che l'algoritmo basato sul flusso massimo risolve correttamente il problema del Bipartite Matching, dobbiamo stabilire una precisa equivalenza tra le soluzioni dei due problemi.
Nello specifico, vale il seguente lemma: 
\paragraph{Lemma}
La dimensione del matching massimo in $G$ è uguale al valore del flusso massimo nella rete trasformata $G'$.
Inoltre, gli archi che fanno parte del matching in $G$ corrispondono esattamente agli archi che trasportano flusso positivo (flusso pari a 1) da $X$ a $Y$ in $G'$.

\paragraph{Dimostrazione}
Dimostriamo questa equivalenza analizzando le due direzioni:

\begin{enumerate}
    \item \textbf{Da Matching a Flusso ($M \to f$):}
    Supponiamo che il grafo $G$ possieda un matching $M = \{(x_1, y_1), (x_2, y_2), \dots, (x_k, y_k)\}$ di dimensione $k$.
    Possiamo costruire un flusso $f$ in $G'$ inviando $1$ unità di flusso lungo ogni cammino della forma $s \to x_i \to y_i \to t$ per ogni coppia $(x_i, y_i) \in M$.
    Poiché $M$ è un matching, ogni nodo $x_i$ e $y_i$ appare al più una volta, quindi i cammini sono disgiunti rispetto ai nodi interni e rispettano le capacità unitarie degli archi.
    La somma totale del flusso sarà quindi pari a $k$, dimostrando che esiste un flusso di valore almeno pari alla dimensione del matching.

    \item \textbf{Da Flusso a Matching ($f \to M$):}
    Supponiamo di aver calcolato un flusso $f$ in $G'$ di valore $k$.
    Poiché tutte le capacità in $G'$ sono intere (nello specifico, pari a 1), per la proprietà di integrità dei flussi, il flusso su ogni arco sarà intero, ovvero $0$ oppure $1$.
    Definiamo $M$ come l'insieme degli archi $(x_i, y_i)$ tali che il flusso tra $x_i$ e $y_i$ sia pari a 1. Poiché il valore totale del flusso è $k$, e il taglio $(X, Y)$ separa $s$ da $t$, ci devono essere esattamente $k$ archi tra $X$ e $Y$ che trasportano 1 unità di flusso. Quindi $|M| = k$.
    
    Resta da dimostrare che $M$ è un matching valido. Dobbiamo verificare che nessun nodo sia incidente a più di un arco in $M$:
    \begin{itemize}
        \item \textbf{Per i nodi in $X$:} Ogni nodo $x \in X$ riceve flusso solo dalla sorgente $s$ tramite l'arco $(s, x)$, che ha capacità 1. Pertanto, il flusso entrante in $x$ è al massimo 1. Per la conservazione del flusso, il flusso uscente da $x$ verso i nodi in $Y$ non può superare 1. Se $x$ fosse adiacente a due o più archi in $M$, uscirebbero 2 o più unità di flusso, il che è impossibile.
        \item \textbf{Per i nodi in $Y$:} Simmetricamente, ogni nodo $y \in Y$ invia flusso solo alla destinazione $t$ tramite l'arco $(y, t)$, che ha capacità 1. Il flusso uscente da $y$ è al massimo 1. Di conseguenza, il flusso entrante in $y$ dai nodi di $X$ non può superare 1. Se $y$ fosse adiacente a due o più archi in $M$, riceverebbe 2 o più unità di flusso, violando il vincolo di capacità sull'arco verso la destinazione.
    \end{itemize}
    Concludiamo che ogni nodo partecipa a un solo arco con flusso positivo, rendendo $M$ un matching valido.
\end{enumerate}

\clearpage
\begin{figure}[!ht]
    \centering
    \includegraphics[width=1\textwidth]{immagini/NetworkFlow/matching.png}
    \caption{Esempio di corrispondenza tra flusso massimo e matching massimo in un grafo bipartito.}
    \label{fig:matching}
\end{figure}

\paragraph{Complessità Computazionale}
La complessità temporale dell'algoritmo è $O(nm)$.
Questo deriva dal fatto che il valore massimo del flusso (e quindi la dimensione massima del matching) non può superare $n/2$ (poiché ogni nodo può essere abbinato una sola volta). Utilizzando un algoritmo di calcolo del flusso come Ford-Fulkerson su una rete con capacità unitarie, ogni aumento di flusso richiede una visita del grafo ($O(m)$), e il numero totale di aumenti è limitato dal valore del flusso massimo ($O(n)$).




