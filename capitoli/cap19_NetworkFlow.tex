\chapter{Network Flow}
\label{cap:NetworkFlow}

I problemi di \textbf{Network Flow} sono una classe fondamentale di problemi che si presentano
nell'ambito del traffico in movimento in una una rete di trasporto.

Concettualmente, questa tipologia di problemi nasce nel contesto della gestione del traffico all'interno di una rete di trasporto fisica. L'intuizione di base è modellare lo spostamento di entità materiali (come veicoli, merci, pacchetti di rete) attraverso un sistema interconnesso soggetto a vincoli fisici. In questa analogia con le reti di trasporto:

\begin{itemize}
    \item \textbf{Gli archi (Edges):} rappresentano i canali di comunicazione o le strade che trasportano il traffico. Ogni arco possiede una capacità intrinseca che limita la quantità di flusso che può attraversarlo.
    \item \textbf{I nodi (Nodes):} fungono da giunzioni tra gli archi e operano come scambi (switches). Il loro compito è ricevere il flusso in entrata e ridistribuirlo sugli archi in uscita, rispettando solitamente un principio di conservazione (tutto ciò che entra deve uscire, salvo che per nodi speciali).
    \item \textbf{Il flusso (Flow):} è la quantità che deve essere spostata da specifici nodi di origine, detti \emph{sorgenti} (sources), verso nodi di destinazione, detti \emph{pozzi} (sinks).
\end{itemize}

\noindent
Sebbene l'origine intuitiva risieda nella logistica e nei trasporti, l'astrazione matematica fornita dalla teoria dei grafi permette di applicare i problemi di Network Flow a una vasta gamma di campi totalmente distinti.

\begin{itemize}
    \item \textbf{Reti di calcolatori:} instradamento dei pacchetti dati attraverso Internet massimizzando la banda passante.
    \item \textbf{Visione artificiale:} segmentazione delle immagini.
    \item \textbf{Scheduling e allocazione risorse:} assegnazione ottimale di compiti a macchine o persone.
    \item \textbf{Matching in grafi bipartiti:} accoppiamento massimo in contesti sociali o economici.
\end{itemize}


\clearpage
\section{Flow Network - Rete di flusso}
Una \textbf{Flow Network}\footnote{
    Con \emph{Flow Network} (tradotto come \textbf{Rete di flusso}) si indica l'oggetto combinatorio statico, ovvero il grafo $G$ dotato di capacità; con \emph{Network Flow} (tradotto come \textbf{Flusso} o \textbf{Flusso su rete}) si intende invece la classe di problemi di ottimizzazione associata.
} 
(\emph{rete di flusso}) è un grafo orientato $G = (V, E)$ che rispetta dei vincoli specifici:
\begin{itemize}
    \item Ogni arco $e \in E$ è associato con un peso non negativo che rappresenta la \textbf{capacità} $c_e$ dell'arco. La capacità indica la quantità massima di flusso che può attraversare l'arco.
    \item Esiste un nodo sorgente (\textbf{source}) $s \in V$ da cui il flusso ha origine.
    \item Esiste un nodo destinazione (o pozzo) (\textbf{sink}) $t \in V$ dove il flusso termina.
    \item Tutti gli altri nodi sono detti \textbf{nodi interni}. Tutto il flusso in entrata in un nodo interno deve essere uguale al flusso in uscita da quel nodo.
\end{itemize}

\vspace{1\baselineskip}
\noindent
Per il resto del capitolo, ci basiamo su delle assunzioni che ci aiuteranno a rendere più semplice la trattazione dei problemi di Network Flow, senza perdere di generalità.
\begin{itemize}
    \item La capacità $c_e$ di ogni arco $e$ è un numero intero (non negativo).
    \item Il nodo sorgente $s$ non ha archi entranti.
    \item Il nodo destinazione $t$ non ha archi uscenti.
    \item Ciascun nodo interno ha almeno un arco incidente.
\end{itemize}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.4\textwidth]{immagini/NetworkFlow/flow_network_ex.png}
    \caption{Esempio di Flow Network, con sorgente $s$ e destinazione $t$, e capacità associate agli archi.}
    \label{fig:flow_network_ex}
\end{figure}

\clearpage
\paragraph{Definizione di Flusso} 
Un \textbf{s-t Flow} in una Flow Network $G = (V, E)$ è una funzione
$ f: E \rightarrow R_{\geq 0} $ tale che:
\begin{itemize}
    \item \textbf{Capacity condition:} Per ogni arco $e \in E$, $f(e)$ rappresenta la quantità di traffico trasportata dall'arco, e deve rispettare la condizione di capacità:
    \[
        0 \leq f(e) \leq c_e 
    \]
    \item \textbf{Conservation condition:} Per ogni nodo interno $v$ (quindi, esclusi $s$ e $t$), si ha:
    \[
        \sum_{e \text{ into } v} f(e) = \sum _{e \text{ out of } v} f(e)
    \]
\end{itemize}

\noindent
Dove $\sum_{e \text{ into } v} f(e)$ somma il valore di flusso $f(e)$ su tutti gli archi che entrano nel nodo $v$, mentre $\sum _{e \text{ out of } v} f(e)$ è la somma dei valori di flusso su tutti gli archi che escono dal nodo $v$.

Dunque il flusso su un arco non può superare la capacità dell'arco stesso. Per ogni nodo diverso dalla sorgente e dalla destinazione, la quantità di flusso in entrata deve essere uguale alla quantità di flusso in uscita. La sorgente non ha archi in entrata (per la nostra assunzione), ma è permesso che abbia flusso in uscita; in altre parole, la sorgente può generare flusso. Simmetricamente, per la destinazione è permesso avere flusso in entrata, anche se non ha archi in uscita. 

Il valore di un flusso $f$, denotato $v(f)$, è definito come la quantità di flusso generata alla sorgente, ovvero la somma di tutti i flussi uscenti dalla sorgente:
\[
    v(f) = \sum_{e \text{ out of } s} f(e).
\]


\vspace{1\baselineskip}
\noindent
Per rendere la notazione più compatta, definiamo per ogni nodo $v \in V$ le seguenti quantità:
\[
    f^{in}(v) = \sum_{e \text{ into } v} f(e)
    \quad \text{e} \quad
    f^{out}(v) = \sum_{e \text{ out of } v} f(e)
\] 

\noindent
È possibile estendere questa definizione a insiemi di vertici: se $S \subseteq V$ è un insieme di nodi, definiamo: 
\[
    f^{in}(S) = \sum_{e \text{ into } S} f(e) 
    \quad \text{e} \quad 
    f^{out}(S) = \sum_{e \text{ out of } S} f(e).
\]

\noindent
In questa terminologia, la condizione di conservazione per i nodi $v \neq s, t$ diventa $f^{in}(v) = f^{out}(v)$; e possiamo scrivere $v(f) = f^{out}(s)$.

Si noti che la sorgente $s$ è l'unico nodo per cui $0 = f^{in}(s) < f^{out}(s)$, mentre la destinazione $t$ è l'unico nodo per cui $f^{in}(t) > f^{out}(t) = 0$.


\clearpage
\section{Maximum Flow Problem}
Data una rete di flusso $G = (V, E)$ con sorgente $s$ e destinazione $t$, un obiettivo naturale è determinare la massima capacità trasmissiva del sistema. Non ci limitiamo a cercare un instradamento qualsiasi, ma vogliamo sfruttare al massimo le capacità degli archi disponibili.

Il problema del \textbf{Maximum Flow} (Flusso Massimo) consiste nel trovare un flusso $f$ che massimizzi il valore totale del flusso in uscita dalla sorgente $v(f) = f^{out}(s)$.


\vspace{1\baselineskip}
\noindent
Supponiamo di voler trovare un flusso massimo in una rete. Scartata la programmazione dinamica, per la quale non esistono algoritmi noti in questo contesto, esploriamo un approccio greedy.

Partiamo da una situazione di flusso nullo: $f(e) = 0$ per ogni arco $e$. Sebbene questa configurazione rispetti i vincoli di capacità e conservazione, il valore del flusso è $0$. Proviamo quindi ad aumentare il valore di $f$ "spingendo" flusso lungo un cammino dalla sorgente $s$ alla destinazione $t$, fino ai limiti imposti dalle capacità degli archi.

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.9\textwidth]{immagini/NetworkFlow/greedy_flow_ex.png}
    \caption{(a) La rete della Figura \ref{fig:flow_network_ex}. (b) Un flusso valido di valore 20 che non permette ulteriori aumenti diretti. (c) L'aumento del flusso a 30 richiede di ridirigere il flusso esistente (linee tratteggiate).}
    \label{fig:greedy_flow_ex}
\end{figure}

\noindent
Facendo riferimento alla Figura~\ref{fig:greedy_flow_ex}, potremmo scegliere il cammino composto dagli archi $\{(s, u), (u, v), (v, t)\}$, portando il flusso su ciascuno di essi a $20$ e lasciando a $0$ gli altri.
Non siamo però all'ottimo (pari a $30$), pur trovandoci in uno stallo: non esistono altri cammini $s-t$ con capacità disponibile per un aumento diretto.

\noindent
Per sbloccare la situazione è necessario ridirigere il flusso esistente, come in Figura~\ref{fig:greedy_flow_ex}(c):

\begin{enumerate}
    \item Spingiamo $10$ unità di flusso lungo $(s, v)$; questo crea un eccesso di flusso entrante in $v$.
    \item Per compensare, "annulliamo" $10$ unità di flusso sull'arco $(u, v)$. Questo ripristina la conservazione in $v$, ma lascia troppo poco flusso in uscita da $u$.
    \item Infine, spingiamo $10$ unità lungo $(u, t)$, ripristinando la conservazione in $u$.
\end{enumerate}

\noindent
Questa operazione porta il flusso totale a $30$. L'intuizione fondamentale è che un algoritmo generale deve poter spingere flusso non solo in avanti (sfruttando la capacità residua), ma anche \textbf{indietro} (sugli archi già utilizzati). Tale meccanismo viene formalizzato introducendo il \textbf{Grafo Residuo}.


\clearpage
\subsection{Residual Graph}
Data una rete di flusso $G = (V, E)$, e un flusso $f$ su $G$. Definiamo il \textbf{grafo residuo} $G_f$ di $G$ rispetto a $f$ come segue.
\begin{itemize}
    \item L'insieme dei nodi di $G_f$ è lo stesso di quello di $G$.
    \item Per ogni arco $e = (u, v)$ di $G$ per cui $f(e) < c_e$, esistono $c_e - f(e)$ unità di capacità "residua" su cui possiamo provare a spingere flusso in avanti. Quindi includiamo l'arco $e = (u, v)$ in $G_f$, con una capacità di $c_e - f(e)$. Chiameremo questi archi \textbf{archi in avanti} (\emph{forward edges}).
    \item Per ogni arco $e = (u, v)$ di $G$ per cui $f(e) > 0$, esistono $f(e)$ unità di flusso che possiamo eventualmente "annullare" spingendo flusso all'indietro. Quindi includiamo l'arco $e' = (v, u)$ in $G_f$, con una capacità di $f(e)$. Si noti che $e'$ ha gli stessi estremi di $e$, ma la sua direzione è invertita; chiameremo questi archi \textbf{archi all'indietro} (\emph{backward edges}). 
\end{itemize}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=1\textwidth]{immagini/NetworkFlow/residual_graph_ex.png}
    \caption{(a) Il grafo $G$ con il cammino $s, u, v, t$ usato per spingere le prime 20 unità di flusso.
    (b) Il grafo residuo del flusso risultante $f$, con la capacità residua accanto a ogni arco. La linea tratteggiata è il nuovo cammino aumentante (augmenting path). (c) Il grafo residuo dopo aver spinto ulteriori 10 unità di flusso lungo il nuovo cammino aumentante $s, v, u, t$.}
    \label{fig:residual_graph_ex}
\end{figure}

\noindent
Da notare che ciascun arco $e$ in $G$ può generare uno o due archi in $G_f$. Se $0 < f(e) < c_e$ risulta che sia un arco in avanti sia uno all'indietro sono inclusi in $G_f$. Questo comporta quindi che $G_f$ ha al più il doppio degli archi di $G$. 

A volte ci riferiremo alla capacità di un arco nel grafo residuo come \textbf{capacità residua}, per distinguere dalla capacità dell'arco corrispondente nella rete di flusso originale $G$.


\clearpage
\subsection{Augmenting Path}
Sia $P$ un cammino semplice da $s$ a $t$ in $G_f$ (cioè, $P$ non visita alcun nodo più di una volta). Definiamo \texttt{bottleneck(P, f)} come la \textbf{capacità residua minima} di qualsiasi arco su $P$, rispetto al flusso $f$.
Di seguito definiamo l'operazione \texttt{augment(f, P)}, che produce un nuovo flusso $f'$ in $G$.

\vspace{1\baselineskip}
\hrule
\begin{verbatim}
Input: P è un cammino semplice s-t in G_f
       f è un flusso in G
Output: f' è un flusso in G ottenuto aumentando f lungo P
1.  Algorithm augment(P, f):
2.      let b = bottleneck(P, f)
3.      for each edge e = (u, v) in P do  # P composto da archi di G_f
4.          if e is a forward edge then
5.              f'(e) = f(e) + b
6.          else
7.              f'(e) = f(e) - b
8.      return f'  
\end{verbatim}
\hrule 
\vspace{1\baselineskip}

\noindent
È stato proprio per poter eseguire questa operazione che abbiamo definito il grafo residuo; per riflettere l'importanza di \texttt{augment}, si indica spesso come \textbf{cammino aumentante} (\emph{augmenting path}) qualsiasi cammino $s-t$ nel grafo residuo.
Il risultato di \texttt{augment(f , P)} è un nuovo flusso $f'$ in $G$, ottenuto aumentando e diminuendo i valori di flusso sugli archi di $P$. 

\paragraph{Proposizione}
Sia $G = (V, E)$ una rete di flusso, e sia $f$ un flusso in $G$. Sia $P$ un cammino semplice $s-t$ in $G_f$. Allora l'output $f'$ di \texttt{augment(f , P)} è un flusso in $G$.

\paragraph{Dimostrazione}
Per dimostrare che $f'$ sia effettivamente un flusso, dobbiamo verificare che $f'$ soddisfi le capacity conditions e conservation conditions.

Iniziamo con la capacity condition.
\begin{itemize}
    \item \textbf{Arco in avanti:} Se $(u, v)$ è un arco in avanti in $G_f$, esso corrisponde all'arco $e = (u, v) \in E$, con capacità residua $c_f(e) = c_e - f(e)$.
    Il nuovo flusso sarà $f'(e) = f(e) + b$. Poiché $b \leq c_e - f(e)$, otteniamo:
    \[
        0 \leq f(e) \leq f'(e) = f(e) + b \leq f(e) + (c_e - f(e)) = c_e
    \]
    La capacity condition è verificata.

    \item \textbf{Arco all'indietro:} Se $(u, v)$ è un arco all'indietro in $G_f$, esso deriva dall'arco fisico $e = (v, u) \in E$, con capacità residua $c_f(e) = f(e)$.
    Poiché stiamo diminuendo il flusso sull'arco originale di $b$, abbiamo:
    \[
        c_e \geq f(e) \geq f'(e) = f(e) - b \geq f(e) - f(e) = 0
    \]
    La capacity condition è verificata anche in questo caso.
\end{itemize}
\noindent
In entrambi i casi, il nuovo flusso rispetta i limiti imposti dalle capacità $c_e$ e la non negatività.

Passiamo alla conservation condition.
Dobbiamo verificare che per ogni nodo interno $v$ appartenente al cammino $P$, la variazione della quantità di flusso in entrata in $v$ è la stessa della variazione della quantità di flusso in uscita da $v$.\footnote{
    Sulle slide del corso, il continuo di questa seconda parte della dimostrazione non è presente; le slide si limitano a enunciare che \texttt{augment} preserva la conservazione del flusso, senza fornire ulteriori dettagli.
} Siano $u$ il nodo precedente e $w$ il nodo successivo a $v$ lungo il cammino $P$ in $G_f$ (ovvero $u \to v \to w$).
Poiché $f$ soddisfa la conservazione, è sufficiente mostrare che la variazione di flusso apportata da \texttt{augment} preserva l'equilibrio tra flusso entrante e uscente. Distinguiamo i quattro casi possibili in base alla tipologia degli archi $(u, v)$ e $(v, w)$ nel grafo residuo:

\begin{itemize}
    \item \textbf{Forward $\to$ Forward:} Entrambi gli archi sono in avanti.
    In $G$ esistono gli archi fisici $e_1 = (u, v)$ ed $e_2 = (v, w)$.
    L'operazione aumenta il flusso su entrambi di $b$. Di conseguenza, il flusso entrante in $v$ aumenta di $b$ (da $e_1$) e quello uscente aumenta di $b$ (su $e_2$). L'equilibrio è mantenuto.

    \item \textbf{Backward $\to$ Backward:} Entrambi gli archi sono all'indietro.
    In $G$ esistono gli archi fisici $e_1 = (v, u)$ ed $e_2 = (w, v)$.
    L'operazione diminuisce il flusso su entrambi di $b$.
    Diminuendo il flusso su $e_1$ (uscente da $v$), riduciamo l'uscita totale di $b$. Diminuendo il flusso su $e_2$ (entrante in $v$), riduciamo l'entrata totale di $b$.
    Poiché entrata e uscita diminuiscono della stessa quantità, l'equilibrio è mantenuto.

    \item \textbf{Forward $\to$ Backward:} L'arco entrante è in avanti, quello uscente è all'indietro.
    In $G$ esistono gli archi fisici $e_1 = (u, v)$ ed $e_2 = (w, v)$.
    Aumentiamo il flusso su $e_1$ di $b$ (aumento dell'entrata).
    Diminuiamo il flusso su $e_2$ di $b$ (diminuzione dell'entrata).
    La variazione netta del flusso entrante è $+b - b = 0$, mentre il flusso uscente resta invariato. L'equilibrio è mantenuto.

    \item \textbf{Backward $\to$ Forward:} L'arco entrante è all'indietro, quello uscente è in avanti.
    In $G$ esistono gli archi fisici $e_1 = (v, u)$ ed $e_2 = (v, w)$.
    Diminuiamo il flusso su $e_1$ di $b$ (diminuzione dell'uscita).
    Aumentiamo il flusso su $e_2$ di $b$ (aumento dell'uscita).
    La variazione netta del flusso uscente è $-b + b = 0$, mentre il flusso entrante resta invariato. L'equilibrio è mantenuto.
\end{itemize}
\noindent
In tutti i casi, la proprietà di conservazione del flusso continua a valere per $f'$.

\clearpage
\subsection{MaxFlow Algorithm}
Questa operazioni di \emph{augmentation} ci permette di modificare un flusso esistente spingendo ulteriore flusso lungo cammini aumentanti nel grafo residuo.
Ripetendo questa procedura, possiamo incrementare il valore del flusso fino a quando non esistono più cammini aumentanti nel grafo residuo. A questo punto, il flusso ottenuto è massimo.

Di seguito è riportato lo pseudocodice dell'algoritmo \textbf{MaxFlow}, o algoritmo di Ford-Fulkerson.

\vspace{1\baselineskip}
\hrule
\begin{alltt}
1. \textbf{Algorithm} Max-Flow(\(G\)):
2.     Initialize \(f(e) = 0\) for all edges \(e\) in \(G\)
3.     Construct the residual graph \(G\sb{f}\)
4.     \textbf{while} there is an \(s\)-\(t\) path in \(G\sb{f}\) \textbf{do}
5.         Let \(P\) be a simple \(s\)-\(t\) path in \(G\sb{f}\)
6.         \(f' = \text{Augment}(P, f)\)
7.         \(f = f'\)
8.         \(G\sb{f} = G\sb{f'}\)
9.     \textbf{return} \(f\)
\end{alltt}
\hrule 
\vspace{1\baselineskip}

\noindent
L'algoritmo MaxFlow risulta piuttosto intuitivo. Ciò che può sembrare meno ovvio è capire se il ciclo \texttt{While} termina, e se il flusso restituito sia effettivamente massimo.

Per analizzare la correttezza e la terminazione dell'algoritmo, è necessario richiamare un'assunzione già fatta sulla natura delle capacità, che ora ripetiamo: assumiamo inizialmente che tutte le capacità degli archi $c(e)$ siano numeri interi.

Sotto questa ipotesi, dimostriamo inizialmente che l'algoritmo Max-Flow termina, e ne analizziamo la complessità; solo in un secondo momento dimostreremo che tale algoritmo produce un flusso massimo. La dimostrazione si basa su due proprietà fondamentali che valgono a ogni iterazione del ciclo \texttt{while}.

\paragraph{Proprietà 1: Flussi e capacità residue come numeri interi}
Possiamo facilmente osservare che in ogni fase intermedia dell'algoritmo i valori del flusso $f(e)$ e le capacità residue in $G_f$ rimangono interi.
\begin{itemize}
    \item Prima del ciclo \texttt{while}, il flusso è inizializzato a $0$ ovunque, e le capacità residue coincidono con le capacità originali (che sono intere per ipotesi).
    \item Ad ogni step, quando troviamo un cammino aumentante $P$, calcoliamo il valore $b = \texttt{bottleneck}(P, f)$. Essendo $b$ il minimo tra le capacità residue degli archi di $P$ (che sono intere), anche $b$ sarà un intero. Di conseguenza, anche le nuove capacità residue nel passo successivo rimarranno intere.
\end{itemize}

\paragraph{Proprietà 2: Il valore del flusso cresce strettamente}
Dimostriamo che ad ogni iterazione il valore del flusso aumenta di almeno 1 unità: $v(f') \geq v(f) + 1$.
Consideriamo il primo arco $e$ del cammino aumentante $P$. Poiché $P$ inizia da $s$, $e$ deve essere un arco uscente dalla sorgente in direzione del grafo residuo. Per definizione di grafo residuo, un arco esiste in $P$ solo se la sua capacità residua è strettamente positiva: $c_f(e) > 0$.
Poiché le capacità sono intere e $P$ è un cammino valido in $G_f$, la capacità residua minima $b$ deve essere almeno $1$ ($b \geq 1$).
L'operazione \texttt{Augment} aumenta il flusso su questo arco di $b$, incrementando di conseguenza il flusso totale uscente da $s$. Pertanto:
\[
    v(f') = f'^{out}(s) = f^{out}(s) + b \geq f^{out}(s) + 1 = v(f) + 1 
\]

\paragraph{Terminazione}
Per provare che l'algoritmo termina, definiamo $C$ come la somma totale delle capacità degli archi uscenti dalla sorgente $s$:
\[ C = \sum_{e \text{ out of s }} c(e) \]
Il valore di un qualsiasi flusso ammissibile non può mai superare la capacità fisica totale degli archi che lasciano la sorgente, quindi $v(f) \leq C$.
Poiché partiamo da un flusso nullo ($v(f)=0$) e ad ogni iterazione il valore aumenta di almeno un intero ($v(f_{i+1}) \geq v(f_i) + 1$), l'algoritmo non può eseguire più di $C$ iterazioni. Questo garantisce la terminazione.

\paragraph{Analisi della Complessità}
Valutiamo ora il costo computazionale. Il tempo totale è dato dal numero di iterazioni moltiplicato per il costo di una singola iterazione.

\begin{enumerate}
    \item \textbf{Costo per iterazione:} In ogni passo dobbiamo trovare un cammino $s-t$ nel grafo residuo $G_f$ e aggiornare i flussi.
    \begin{itemize}[nosep]
        \item La ricerca del cammino può essere effettuata con una visita in ampiezza (BFS) o profondità (DFS).\footnote{
            In pratica si preferisce la BFS perché, trovando sempre il cammino più breve in termini di numero di archi, evita i casi patologici in cui il flusso viene incrementato di quantità minime, garantendo così una convergenza molto più rapida (polinomiale) rispetto a una scelta arbitraria o basata su DFS.
        } Questo richiede tempo $O(m + n)$.
        \item L'aggiornamento delle capacità e dei flussi lungo il cammino richiede tempo proporzionale alla lunghezza del cammino stesso, che è al più $O(n)$.
    \end{itemize}
    Pertanto, ogni iterazione costa $O(m)$ se si assume che il grafo sia connesso ($m \geq n - 1$).

    \item \textbf{Numero di iterazioni:} Come dimostrato, il numero massimo di aumenti è limitato da $C$.
\end{enumerate}
\noindent
Combinando questi fattori, la complessità temporale dell'algoritmo\footnote{ 
    È importante notare che la complessità $O(m C)$ non è polinomiale in senso stretto, ma \emph{pseudo-polinomiale}. La complessità non dipende solo dalla dimensione dell'input (numero di nodi e archi), ma anche dal valore numerico $C$. Se $C$ è grande rispetto alla dimensione del grafo, l'algoritmo può diventare inefficiente.
} Max-Flow è:
\[ O(m \cdot C) \]








