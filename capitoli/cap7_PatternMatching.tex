\chapter{Pattern Matching}
\label{cap:PatternMatching}



Introduciamo di seguito la terminologia di base:
\begin{itemize}
    \item \(\Sigma\) : l'alfabeto, ovvero l'insieme di caratteri possibili.
    \item \(|\Sigma|\) : la dimensione dell'alfabeto.
    \item Stringa \( S \) : una sequenza finita di caratteri appartenenti all'alfabeto \(\Sigma\), di lunghezza \( m \).
    \item \(S[i]\) : il carattere alla posizione \( i \) della stringa \( S \).
    \item \(S[i..j]\) : la sottostringa di \( S \) che va dall'indice \( i \) all'indice \( j \).
        \begin{itemize}
            \item In Python: $S$[i:j+1] 
        \end{itemize}
    \item \(S[0..k]\) : prefisso di lunghezza \( k+1 \) della stringa \( S \).
        \begin{itemize}
            \item In Python: $S$[:k+1]
        \end{itemize}
    \item \(S[j..m-1]\) : suffisso di lunghezza \( m-j \) della stringa \( S \). 
        \begin{itemize}
            \item In Python: $S$[j:]
        \end{itemize}
\end{itemize}

\noindent
Nel classico problema di pattern matching, ci viene data una stringa di testo $T$ di lunghezza $n$ e una stringa di pattern $P$ di lunghezza $m$, e vogliamo scoprire se $P$ è una sottostringa di $T$. In tal caso, potremmo voler trovare l'indice più basso $j$ all'interno di $T$ in cui inizia $P$, in modo che $T[j..j+m-1]$ sia uguale a $P$, o forse trovare tutti gli indici di $T$ in cui inizia il pattern $P$.

\clearpage
\section{Brute Force}
Il metodo più semplice per risolvere il problema del pattern matching è il metodo \textit{brute force}. L'idea alla base di questo metodo è di confrontare il pattern $P$ con ogni possibile sottostringa di $T$ di lunghezza $m$. In particolare, per ogni indice $i$ da $0$ a $n-m$, confrontiamo la sottostringa $T[i..i+m-1]$ con il pattern $P$. Se troviamo una corrispondenza, restituiamo l'indice $i$.

\vspace{1\baselineskip}
\begin{lstlisting}
def find_brute(T, P):
    """Return the lowest index of T at which substring P begins (or else -1)."""
    n, m = len(T), len(P)  # introduce convenient notations
    for i in range(n-m+1):  # try every potential starting index within T
        k = 0  # an index into pattern P
        while k < m and T[i + k] == P[k]:  # kth character of P matches
            k += 1
        if k == m:  # if we reached the end of pattern,
            return i  # substring T[i:i+m] matches P
    return -1  # failed to find a match starting with any i
\end{lstlisting}
\vspace{1\baselineskip}


\subsection*{Performance}
L'algoritmo consiste in due cicli annidati, con il ciclo esterno che scorre tutti i possibili indici iniziali del pattern nel testo $T$, e il ciclo interno che scorre ogni carattere del pattern $P$, confrontandolo con il suo potenziale carattere corrispondente nel testo. Pertanto, la correttezza dell'algoritmo deriva direttamente da questo approccio di ricerca esaustiva.

Il tempo di esecuzione del pattern matching tramite \emph{Brute Force} nel caso peggiore non è buono poiché per ogni indice candidato in $T$, possiamo eseguire fino a $m$ confronti di caratteri per scoprire che $P$ non corrisponde a $T$ all'indice corrente. Dal blocco di codice si può osservare che il ciclo $for$ esterno viene eseguito al massimo $n-m+1$ volte e il ciclo $while$ interno viene eseguito al massimo $m$ volte. Pertanto, il tempo di esecuzione nel caso peggiore è $O(n m)$.

\clearpage
\subsection*{Esempio}
Supponiamo di avere un testo 
$$ T = \text{"abacaabaccabacabaabb"} $$
e un pattern 
$$ P = \text{"abacab"} $$

\begin{figure}[!ht]
    \centering
    \includegraphics[width=1\textwidth]{immagini/PatternMatching/ex_BruteForce.png}
    \caption{Esempio di Pattern Matching con algoritmo Brute Force. L'algoritmo esegue 27 confronti tra caratteri, numerati in figura.}
\end{figure}


\clearpage
\section{L'algoritmo di Boyer-Moore}
Come vedremo tra poco, non è sempre necessario confrontare ogni carattere del pattern con il testo. L'algoritmo di \emph{Boyer-Moore} sfrutta questa osservazione per saltare alcune posizioni nel testo, riducendo così il numero di confronti necessari. 

L'idea principale dell'algoritmo di \emph{Boyer-Moore} è di migliorare l'efficienza dell'algoritmo \emph{Brute Force} utilizzando due tecniche (euristiche) principali:

\begin{itemize}
    \item \textbf{Looking-Glass Heuristic}: Quando si confrontano i caratteri del pattern con il testo, si inizia dal carattere più a destra del pattern e si procede verso sinistra.
    \item \textbf{Character-Jump Heuristic}: Durante la verifica di un possibile piazzamento di $P$ in $T$, un mismatch tra $T[i] = c$ e $P[k]$ viene gestito come segue:
    
    Supponiamo che $T[i] \neq P[k]$ e $T[i] = c$.
        \begin{itemize}
            \item Se $c$ non appare in $p$, $p$ può essere "spostato" completamente oltre $T[i]$ ($P[0]$ viene allineato con $T[i+1]$).
            \item Altrimenti, $T[i]$ viene allineato con l'ultima occorrenza di $c$ in $P$.
        \end{itemize}
\end{itemize}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.8\textwidth]{immagini/PatternMatching/ex_BoyerMoore.png}
    \caption{Una semplice dimostrazione dell'algoritmo di Boyer-Moore. Nel primo confronto si ha $T[4] \neq P[4]$ con $T[4] = \text{'e'}$ che non è presente in $P$, per cui spostiamo $P$ oltre $T[4]$. Nel secondo confronto si ha $T[9] \neq P[4]$ con $T[9] = \text{'s'}$ che è presente in $P$, in particolare l'ultima occorrenza di 's' è in $P[2]$, per cui allineiamo $P[2]$ con $T[9]$.}
    \label{exBoyerMoore}
\end{figure}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.8\textwidth]{immagini/PatternMatching/ex2_BoyerMoore.png}
    \caption{Esmepio completo che mostra il numero di confronti.}
    \label{ex2BoyerMoore}
\end{figure}

\clearpage
\noindent
Per formalizzare l'algoritmo di \emph{Boyer-Moore} possiamo generalizzare il funzionamento come di seguito:

\begin{itemize}
    \item Quando viene trovata una corrispondenza (a partire dall'ultimo carattere del pattern), l'algoritmo continua cercando di estendere la corrispondenza con il penultimo carattere del pattern nel suo allineamento corrente. Questo processo continua fino a quando tutti i caratteri del pattern sono stati confrontati con esito positivo o fino a quando si verifica un mismatch.
    \item Quando si verifica un mismsatch, e il carattere del testo che ha causato il mismatch non è presente nel pattern, il pattern viene spostato completamente oltre quel carattere del testo. Se il carattere del testo è presente da qualche altra parte nel pattern, dobbiamo considerare due diversi casi a seconda che la sua ultima occorrenza sia $(a)$ precedente o $(b)$ successiva al carattere del pattern che era allineato con il carattere del testo che ha causato il mismatch.
\end{itemize}

Questi due casi sono rappresentati in figura \ref{fig:BM_mismatch_cases} e approfonfiti di seguito:


