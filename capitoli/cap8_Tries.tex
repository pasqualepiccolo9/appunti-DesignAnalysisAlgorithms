\chapter{Tries}
\label{cap:Tries}

Il problema del \emph{pattern matching} presentato nel capitolo \ref{cap:PatternMatching} velocizza la ricerca in un testo effettuando una pre-elaborazione del pattern (per calcolare la funzione di fallimento nell'algoritmo di Knuth-Morris-Pratt o la funzione last nell'algoritmo di Boyer-Moore). In questa sezione, adottiamo un approccio complementare, presentando algoritmi di ricerca di stringhe che effettuano una pre-elaborazione del testo. Questo approccio è adatto per applicazioni in cui viene eseguita una serie di query su un testo fisso, in modo che il costo iniziale della pre-elaborazione del testo sia compensato da un'accelerazione in ogni query successiva. A questo proposito introduciamo i \emph{tries} (pronunciato "try"), una struttura dati basata su alberi per memorizzare stringhe al fine di supportare un rapido pattern matching. La principale applicazione dei tries è nel recupero delle informazioni, da cui il nome "trie" che deriva dalla parola "retrieval".


\section{Standard Tries}
Sia $S$ un insieme di $s$ stringhe su un alfabeto $\Sigma$ tale che nessuna stringa in $S$ sia prefisso di un'altra stringa. Uno \textbf{Standard Trie} per $S$ è un albero ordinato $T$ con le seguenti proprietà:
\begin{itemize}
    \item Ogni nodo di $T$, eccetto la radice, è etichettato con un carattere di $\Sigma$.
    \item I figli di un nodo interno di $T$ hanno etichette distinte.
    \item $T$ ha $s$ foglie, ciascuna associata a una stringa di $S$, tale che la concatenazione delle etichette dei nodi sul percorso dalla radice a una foglia $v$ di $T$ dia la stringa di $S$ associata a $v$.
\end{itemize}

\noindent
Dunque, un trie $T$ rappresenta le stringhe di $S$ tramite i percorsi dalla radice alle foglie di $T$. È importante assumere che nessuna stringa in $S$ sia prefisso di un'altra sintra poichè ciò garantisce che ogni stringa di $S$ sia univocamente associata a una foglia di $T$. Possiamo sempre soddisfare questa assunzione aggiungendo un carattere speciale che non è nell'alfabeto originale $\Sigma$ alla fine di ogni stringa.

\clearpage
\noindent
Uno standard trie che memorizza una collezione $S$ di $s$ stringhe di lunghezza totale $n$ da un alfabeto $\Sigma$ ha le seguenti proprietà:
\begin{itemize}[nosep]
    \item L'altezza di $T$ è uguale alla lunghezza della stringa più lunga in $S$.
    \item Ogni nodo interno di $T$ può avere da 1 a $|\Sigma|$ figli.
    \item $T$ ha $s$ foglie.
    \item Il numero di nodi di $T$ è al più $n+1$. 
        \begin{itemize}
            \item Infatti, il caso peggiore per il numero di nodi di un trie si verifica quando nessuna coppia di stringhe condivide un prefisso non vuoto; cioè, ad eccezione della radice, tutti i nodi interni hanno un solo figlio.
        \end{itemize}
\end{itemize}

\subsection*{Ricerca}
Un trie $T$ per un insieme $S$ di stringhe permette di implementare una mappa in cui le chiavi sono le stringhe stesse; la ricerca di una stringa $X$ avviene tracciando dalla radice il percorso indicato dai caratteri di $X$ e, se tale percorso termina in un nodo foglia, la stringa è presente nella mappa, mentre se il percorso si interrompe o termina in un nodo interno la stringa non è una chiave valida. 

Il tempo di esecuzione per cercare una stringa di lunghezza $m$ è limitato superiormente da $O(m \cdot |\Sigma|)$, in quanto possiamo visitare al più $m+1$ nodi di $T$ e spendiamo $O(|\Sigma|)$ tempo in ogni nodo per determinare il figlio che ha come etichetta il carattere successivo. Tuttavia, possiamo migliorare il tempo speso in un nodo a $O(\log |\Sigma|)$ o atteso $O(1)$, mappando i caratteri ai figli utilizzando una tabella hash in ogni nodo, oppure utilizzando una lookup table diretta di dimensione $|\Sigma|$ in ogni nodo, se $|\Sigma|$ è sufficientemente piccolo (come nel caso delle stringhe di DNA). Per questi motivi, ci aspettiamo tipicamente che una ricerca per una stringa di lunghezza $m$ venga eseguita in tempo $O(m)$.

\subsection*{Word Matching}
Grazie a queste caratteristiche, il trie è adatto per il \textbf{word matching} esatto e per le query sui prefissi (per via dell'operazione di ricerca appena descritta), ma non per il pattern matching di sottostringhe arbitrarie. Il \emph{word matching} è un caso particolare di pattern matching in cui vogliamo determinare se un dato pattern corrisponde esattamente a una delle parole del testo. Il word matching si differenzia dal pattern matching standard analizzato nel capitolo \ref{cap:PatternMatching} perché in questo caso il pattern non può corrispondere a una sottostringa arbitraria del testo, ma solo a una delle sue parole.

\subsection*{Costruzione di uno Standard Trie}
Per costruire uno standard trie per un insieme $S$ di stringhe, possiamo utilizzare un algoritmo incrementale che inserisce le stringhe una alla volta. Ricordiamo l'assunzione che nessuna stringa di $S$ sia prefisso di un'altra stringa. Per inserire una nuova stringa $X$ nel trie, seguiamo il percorso dei suoi caratteri finché esistono nodi corrispondenti. Nel punto in cui il percorso esistente si interrompe (ovvero non troviamo il carattere successivo), creiamo una nuova sequenza di nodi per tutti i caratteri restanti di $X$. Il tempo di esecuzione per inserire $X$ di lunghezza $m$ è simile a una ricerca, con prestazioni nel caso peggiore di $O(m \cdot |\Sigma|)$, o attese $O(m)$ se si utilizzano tabelle hash secondarie in ogni nodo. Pertanto, la costruzione dell'intero trie per l'insieme $S$ richiede un tempo atteso di $O(n)$, dove $n$ è la lunghezza totale delle stringhe di $S$.

\vspace{1\baselineskip}
\begin{figure}[!ht]
    \centering
    \includegraphics[width=1\textwidth]{immagini/Tries/std_tries_ex.png}
    \caption{Word Matching tramite uno Standard Trie: (a) testo da cercare (articoli e preposizioni, noti anche come stop words, esclusi); (b) standard trie per le parole nel testo, con le foglie che mantengono l'informazione relativa all'indice in cui la data parola inizia nel testo. Ad esempio, la foglia per la parola \emph{stock} indica che la parola inizia agli indici 17, 40, 51 e 62 del testo.}
    \label{fig:std_tries_ex}
\end{figure}

\vspace{1\baselineskip}
Come si può notare anche dall'esempio in Figura \ref{fig:std_tries_ex}, c'è una potenziale inefficienza di spazio nello standard trie dovuta alla presenza di molti nodi che hanno un solo figlio, e l'esistenza di tali nodi rappresenta uno spreco. La ricerca di una soluzione a questo problema ha portato allo sviluppo del \emph{Compressed Trie}, o \emph{Patricia Trie}.  


\clearpage
\section{Compressed Tries}
Un \textbf{Compressed Trie} è una variante dello standard trie che garantisce che ogni nodo interno del trie abbia almeno due figli. Questa regola viene applicata comprimendo le catene di nodi con un solo figlio. 

Sia $T$ un trie standard. Diciamo che un nodo interno $v$ di $T$ è \textbf{ridondante} se $v$ ha un solo figlio e non è la radice. Diciamo anche che una \emph{catena} di $k \geq 2$ archi,
$$ (v_0, v_1)(v_1, v_2) \cdots (v_{k-1}, v_k) $$
è \textbf{ridondante} se:
\begin{itemize}[nosep]
    \item $v_i$ è ridondante per $i = 1, \ldots, k-1$.
    \item $v_0$ e $v_k$ non sono ridondanti.
\end{itemize}

\noindent
Si può trasformare $T$ in un \emph{Compressed Trie} sostituendo ogni catena ridondante $(v_0,v_1) \cdots (v_{k-1},v_k)$ di $k \geq 2$ archi con un singolo arco $(v_0,v_k)$, rietichettando $v_k$ con la concatenazione delle etichette dei nodi $v_1, \ldots, v_k$.

\begin{figure}[!ht]
    \centering
    \includegraphics[width=1\textwidth]{immagini/Tries/compressed_tries_ex.png}
    \caption{Compressed Trie per le stringhe \{bear, bell, bid, bull, buy, sell, stock, stop\}. (Confronta questo con lo standard trie mostrato in Figura \ref{fig:std_tries_ex}.) Oltre alla compressione ai nodi foglia, nota il nodo interno con etichetta "to" condivisa dalle parole "stock" e "stop".}
    \label{fig:compressed_tries_ex}
\end{figure}

I nodi di un compressed trie sono etichettati con delle stringhe, che sono sottostringhe delle stringhe nella collezione, piuttosto che con singoli caratteri. Il vantaggio di un compressed trie rispetto a uno standard trie è che il numero di nodi del compressed trie è proporzionale al numero di stringhe e non alla loro lunghezza totale.

\vspace{1\baselineskip}
\noindent
Un compressed trie che memorizza una collezione $S$ di $s$ stringhe in un alfabeto di dimensione $d$ ha le seguenti proprietà:

\begin{itemize}
    \item Ciascun nodo interno di $T$ ha almeno due figli e al massimo $d$ figli.
    \item $T$ ha $s$ nodi foglia.
    \item Il numero di nodi di $T$ è $O(s)$.
\end{itemize}

\clearpage
\noindent
Il \emph{Compressed Trie} offre un reale vantaggio quando viene utilizzato come struttura di indicizzazione ausiliaria per una collezione di stringhe già memorizzate in una struttura primaria.

Supponiamo, ad esempio, che la collezione $S$ di stringhe sia un array di stringhe $S[0], S[1], \ldots, S[s-1]$. Invece di memorizzare esplicitamente l'etichetta $X$ di un nodo, la rappresentiamo implicitamente mediante una combinazione di tre interi $(i, j : k)$, tali che $X = S[i][ j : k]$; cioè, $X$ è la porzione di $S[i]$ costituita dai caratteri dalla posizione $j$ fino a, ma non includendo, la posizione $k$.

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.9\textwidth]{immagini/Tries/compressed_tries_usage.png}
    \caption{(a) Collezione $S$ di stringhe memorizzata in un array. (b) Rappresentazione compatta del compressed trie per $S$.}
    \label{fig:compressed_tries_usage}    
\end{figure}

\noindent
In questo modo è possibile ridurre lo spazio totale per il trie stesso da $O(n)$ per lo standard trie a $O(s)$ per il compressed trie, dove $n$ è la lunghezza totale delle stringhe in $S$ e $s$ è il numero di stringhe in $S$. Naturalmente, dobbiamo comunque memorizzare le diverse stringhe in $S$, ma riduciamo comunque lo spazio per il trie.

La ricerca in un compressed trie non è necessariamente più veloce che in un albero standard, poiché è ancora necessario confrontare ogni carattere del pattern desiderato con le etichette, potenzialmente multi-carattere, durante la traversata dei percorsi nel trie.


