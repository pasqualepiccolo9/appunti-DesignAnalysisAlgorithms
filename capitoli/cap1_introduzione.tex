\chapter{Introduzione}
\label{cap:Introduzione}

\section{Introduzione all'Approccio Orientato agli Oggetti}
Lo sviluppo di software efficiente si basa sulla progettazione e analisi di algoritmi e strutture dati. L'approccio moderno privilegia la programmazione orientata agli oggetti (OOP) per promuovere la robustezza, la riusabilità e l'adattabilità del software.

\subsection{Concetti Fondamentali}
In questo contesto, i dati non sono entità isolate ma sono incapsulati insieme ai metodi necessari per accedervi e modificarli.
\begin{itemize}
    \item \textbf{Incapsulamento:} I dati sono protetti e accessibili solo tramite un'interfaccia pubblica.
    \item \textbf{Information Hiding:} L'utente interagisce con l'interfaccia senza conoscere i dettagli implementativi interni.
\end{itemize}

\subsection{Design Patterns}
Un \textit{Design Pattern} è una soluzione standard a un problema tipico di progettazione software. Fornisce un modello generale che può essere specializzato per adattarsi a problemi specifici. Un pattern è composto da:
\begin{enumerate}
    \item \textbf{Nome:} Identifica il pattern.
    \item \textbf{Contesto:} Descrive quando può essere applicato.
    \item \textbf{Template:} Descrive come viene applicato.
    \item \textbf{Risultato:} Analizza ciò che il pattern produce.
\end{enumerate}

\noindent
Esempi di pattern includono \textit{Iterator, Adapter, Factory} (Software Engineering) e \textit{Divide-and-Conquer, Greedy} (Algorithm Design).

\section{Abstract Data Types (ADT) vs Strutture Dati}
È fondamentale distinguere tra il modello astratto e la sua realizzazione concreta.

\begin{itemize}
    \item \textbf{Abstract Data Type (ADT):} È un modello matematico che descrive un tipo di dato attraverso i suoi comportamenti (semantica) e i parametri delle operazioni. Descrive \textit{cosa} fanno le operazioni, ma non \textit{come} (punto di vista dell'utente). È indipendente dall'implementazione.
    \item \textbf{Struttura Dati:} È la realizzazione concreta di un ADT. Descrive la rappresentazione in memoria dei dati e l'implementazione degli algoritmi per le operazioni (punto di vista del progettista).
\end{itemize}
In un linguaggio object-oriented, ADT e struttura dati sono realizzati tramite delle classi. Una classe definisce sia l'interfaccia pubblica (ADT) sia l'implementazione effettiva (struttura dati).

\subsection{Come si crea un ADT?}
Per progettare un ADT bisogna seguire i seguenti passi:
\begin{enumerate}
    \item Identificare le operazioni.
    \begin{itemize}
        \item Definire le operazioni che l'ADT deve offrire e quali parametri richiedono.
        \item Descrivere il significato (semantica) di ciascuna operazione.
    \end{itemize}
    \item Definire la classe tramite l'interfaccia.
    \begin{itemize}
        \item Scrivere la classe che rappresenta l'ADT, specificando solo i metodi pubblici (l'interfaccia) necessari all'uso dell'astrazione.
    \end{itemize}
    \item Implementazione di un testing client.
    \begin{itemize}
        \item Creare un programma di test che utilizzi l'ADT per verificare correttezza e efficienza delle operazioni.
    \end{itemize}
\end{enumerate}

\noindent
Per ogni operazione dell'ADT bisogna specificare:
\begin{itemize}
    \item \textbf{Precondizioni:} condizione che deve essere vera prima dell'esecuzione dell'operazione. Se non è soddisfatta, viene generato un errore e lanciata un'eccezione.
    \item \textbf{Post-condizione:} condizione che deve essere vera dopo l'esecuzione dell'operazione, se la precondizione era validata.
\end{itemize}

\subsection{Come si utilizza un ADT?}
Una volta progettato e implementato un ADT, il suo utilizzo avviene esclusivamente tramite la sua interfaccia pubblica, senza conoscere i dettagli interni dell'implementazione. 

\begin{enumerate}
    \item Si crea un'istanza dell'ADT, si dichiara un oggetto della classe che implementa l'ADT.
    \item Usare le operazioni definite dall'interfaccia, chiamare i metodi pubblici per accedere o modificare i dati.
    \item Non accedere mai ai dati interni direttamente: i campi interni sono incapsulati e protetti.
    \item Gestire eccezioni e precondizioni: controllare che le precondizioni delle operazioni siano rispettate; se falliscono , l'ADT può lanciare un'eccezione.
\end{enumerate}

\section{ADT Stack (Pila)}
Uno \textbf{Stack} è una collezione di oggetti inseriti e rimossi secondo il principio \textbf{LIFO} (Last-In, First-Out).

\subsection{Operazioni Fondamentali}
\begin{itemize}
    \item \texttt{push(e)}: Inserisce l'elemento $e$ in cima alla pila.
    \item \texttt{pop()}: Rimuove e restituisce l'elemento in cima. Se vuota, lancia un'eccezione.
    \item \texttt{top()}: Restituisce (senza rimuovere) l'elemento in cima.
    \item \texttt{is\_empty()}: Restituisce \texttt{True} se la pila è vuota.
    \item \texttt{len()}: Restituisce il numero di elementi.
\end{itemize}

\subsection{Implementazione basata su Array}
Una semplice implementazione in Python utilizza una lista dinamica (array dinamico). I dati vengono inseriti da sinistra a destra e una variabile mantiene l'indice dell'ultimo elemento aggiunto (\textit{top}).

\subsubsection{Gestione della Memoria e Analisi Ammortizzata}
Quando l'array è pieno, è necessario ridimensionarlo ("stretching").
\begin{itemize}
    \item Non si può semplicemente estendere la memoria contigua esistente.
    \item Bisogna allocare un nuovo array più grande e copiare gli elementi.
\end{itemize}

\noindent
Se si incrementasse la dimensione di una sola unità per ogni inserimento, il costo sarebbe quadratico nel tempo. La strategia efficiente è il \textbf{Raddoppiamento} della dimensione.

\noindent
\textbf{Analisi Ammortizzata:} Considera il costo totale di una sequenza di operazioni. Sebbene il raddoppiamento costi $O(n)$, esso avviene raramente. Ammortizzando questo costo sulle operazioni economiche ($O(1)$) di inserimento semplice:
\begin{itemize}
    \item \textbf{Costo reale:} 1 (array non pieno) o $O(n)$ (resize).
    \item \textbf{Costo ammortizzato:} $O(1)$ per ogni operazione di \texttt{push}.
\end{itemize}

\subsection{Pattern Adapter}
L'implementazione dello Stack può utilizzare il pattern \textit{Adapter} (o Wrapper). Si utilizza una classe esistente (es. \texttt{list} di Python) e si adatta la sua interfaccia a quella richiesta dall'ADT Stack.

\begin{lstlisting}[language=Python, caption=Esempio di Classe ArrayStack]
class ArrayStack:
    def __init__(self):
        self._data = [] # Lista privata
        
    def push(self, e):
        self._data.append(e) # Adatta append a push
        
    def pop(self):
        if self.is_empty():
            raise Empty('Stack is empty')
        return self._data.pop() # Adatta pop a pop
\end{lstlisting}

\section{Alberi (Trees)}
Un albero è un modello astratto per rappresentare strutture gerarchiche non lineari. È composto da nodi con relazioni padre-figlio.

\subsection{Terminologia}
\begin{itemize}
    \item \textbf{Radice (Root):} Nodo senza padre.
    \item \textbf{Nodo Interno:} Nodo con almeno un figlio.
    \item \textbf{Foglia (Leaf) / Nodo Esterno:} Nodo senza figli.
    \item \textbf{Profondità (Depth) di un nodo:} Numero di antenati.
    \item \textbf{Altezza (Height) dell'albero:} Massima profondità tra i nodi (o altezza della radice).
\end{itemize}

\noindent
Un albero è ordinato se esiste un ordine lineare significativo tra i figli di ciascun nodo.
Ogni figlio può essere identificato come primo, secondo, terzo…
La visualizzazione tipica è quella in cui i fratelli sono allineati da sinistra a destra.

\subsection{ADT Tree}
Un albero $T$ è un insieme di nodi e un insieme di relazioni padre-figlio che soddisfano le seguenti proprietà:
\begin{itemize}
    \item Se $T$ è non vuoto, esiste un nodo speciale chiamato \textbf{radice} che non ha padre.
    \item Ogni nodo $v$ di $T$, diverso dalla radice, ha un unico nodo padre $w$; tutti i nodi che hanno $w$ come padre sono chiamati \textbf{figli} di $w$, e sono tra di loro \textbf{fratelli}. 
\end{itemize}

\noindent
L'ADT Tree definisce metodi di accesso e navigazione generici:
\begin{itemize}
    \item \texttt{root()}: Restituisce la posizione della radice.
    \item \texttt{parent(p)}: Restituisce il genitore della posizione $p$.
    \item \texttt{children(p)}: Restituisce un iteratore sui figli di $p$.
    \item \texttt{is\_leaf(p)}, \texttt{is\_root(p)}: Query booleane.
\end{itemize}

\subsection{Calcolo dell'Altezza e Profondità}
Questi algoritmi sono spesso implementati ricorsivamente.
\begin{equation}
    \text{depth}(p) = 
    \begin{cases} 
    0 & \text{se } p \text{ è la radice} \\
    1 + \text{depth}(\text{parent}(p)) & \text{altrimenti}
    \end{cases}
\end{equation}

\begin{equation}
    \text{height}(p) = 
    \begin{cases} 
    0 & \text{se } p \text{ è una foglia} \\
    1 + \max(\{ \text{height}(c) \mid c \in \text{children}(p) \}) & \text{altrimenti}
    \end{cases}
\end{equation}

\section{Alberi Binari (Binary Trees)}
Un albero binario è un albero ordinato in cui ogni nodo ha \textbf{al massimo due figli}, distinti in \textit{figlio sinistro} e \textit{figlio destro}.

\subsection{ADT BinaryTree}
Estende l'ADT Tree con metodi specifici:
\begin{itemize}
    \item \texttt{left(p)}: Restituisce il figlio sinistro di $p$.
    \item \texttt{right(p)}: Restituisce il figlio destro di $p$.
    \item \texttt{sibling(p)}: Restituisce il fratello di $p$.
\end{itemize}

\subsection{Implementazione Collegata (Linked Structure)}
A differenza degli array, gli alberi sono spesso implementati come strutture collegate per ottimizzare inserimenti e cancellazioni ($O(1)$ per aggiornamenti locali).
Si utilizza una classe annidata \texttt{\_Node} che contiene:
\begin{itemize}
    \item \texttt{\_element}: Il dato memorizzato.
    \item \texttt{\_parent}: Riferimento al nodo padre.
    \item \texttt{\_left}: Riferimento al figlio sinistro.
    \item \texttt{\_right}: Riferimento al figlio destro.
\end{itemize}

\noindent
Inoltre, si utilizza il concetto di \textbf{ADT Position} per incapsulare il nodo. L'utente manipola oggetti di tipo \textit{Position}, non direttamente i nodi, proteggendo la struttura interna.

\subsection{Il Pattern Position}
Per implementare collezioni di elementi, come gli alberi, in modo robusto e astratto, si utilizza il pattern (o ADT) **Position**.

\subsubsection{Concetto e Scopo}
Una \texttt{Position} rappresenta un'astrazione di un "nodo" all'interno della struttura dati. A differenza di un semplice nodo, che potrebbe esporre direttamente i puntatori al padre e ai figli, una Position funge da "segnalibro" o "puntatore sicuro" all'elemento:
\begin{itemize}
    \item È un oggetto che incapsula un elemento.
    \item Protegge la struttura interna: l'utente manipola le posizioni, ma solo la classe albero può accedere ai collegamenti (link) tra i nodi reali sottostanti.
    \item Una Position $p$ rimane valida e non è influenzata dai cambiamenti negli altri nodi, a meno che non venga esplicitamente cancellata.
\end{itemize}
L'unica operazione pubblica principale dell'ADT Position è il metodo per accedere al dato contenuto:
\begin{verbatim}
p.element() # Restituisce l'elemento memorizzato in P
\end{verbatim}

\subsubsection{Implementazione in Python}
Nel contesto dell'implementazione `LinkedBinaryTree`, la classe \texttt{Position} è definita come un wrapper pubblico intorno alla classe privata \texttt{\_Node}.
Ogni istanza di \texttt{Position} memorizza:
\begin{enumerate}
    \item Un riferimento al nodo reale (\texttt{\_node}).
    \item Un riferimento al contenitore a cui appartiene (\texttt{\_container}), utile per verificare che la posizione sia utilizzata con l'albero corretto.
\end{enumerate}
Ecco un esempio dell'implementazione della classe \texttt{Position}:
\clearpage
\begin{lstlisting}[language=Python, caption=Classe Position (Wrapper)]
class Position(BinaryTree.Position):
    """Classe pubblica che avvolge un nodo."""
    def __init__(self, container, node):
        """Costruttore interno, non invocato dall'utente."""
        self._container = container
        self._node = node
        
    def element(self):
        """Restituisce l'elemento contenuto nella Position."""
        return self._node._element
        
    def __eq__(self, other):
        """Restituisce True se other si riferisce alla stessa Position."""
        return type(other) is type(self) and other._node is self._node
\end{lstlisting}

\paragraph{Meccanismo di Validazione:} Per garantire la robustezza, l'albero implementa un metodo interno \texttt{\_validate(p)} che controlla se una data posizione è valida prima di usarla. Una posizione è considerata valida se:
\begin{itemize}[nosep]
    \item È un'istanza della classe corretta.
    \item Appartiene all'istanza dell'albero corrente (\texttt{p.\_container is self}).
    \item Il nodo sottostante non è stato eliminato (spesso i nodi eliminati vengono marcati facendo puntare il loro padre a se stessi).
\end{itemize}

\subsection{Visite dell'Albero (Traversals)}
Esistono diverse strategie per visitare sistematicamente i nodi:
\begin{enumerate}[nosep]
    \item \textbf{Preorder (Anticipata):} Visita la radice, poi ricorsivamente i sottoalberi.
    \item \textbf{Postorder (Posticipata):} Visita ricorsivamente i sottoalberi, poi la radice.
    \item \textbf{Inorder (Simmetrica):} Specifica per alberi binari. Visita sottoalbero sinistro, poi radice, poi sottoalbero destro.
    \item \textbf{Breadth-First (Visita in Ampiezza):} Visita i nodi livello per livello. Richiede l'uso di una \textbf{Coda} (Queue) per memorizzare i nodi da visitare.
\end{enumerate}

\begin{lstlisting}[language=Python, caption=Algoritmo Breadth-First]
def breadthfirst(self):
    if not self.is_empty():
        fringe = ArrayQueue()
        fringe.enqueue(self.root())
        while not fringe.is_empty():
            p = fringe.dequeue()
            yield p
            for c in self.children(p):
                fringe.enqueue(c)
\end{lstlisting}

\clearpage
\section{ADT Map}
Una mappa è una struttura dati usata per implementare l'astrazione del dizionario: permette di cercare, inserire e aggiornare informazioni a partire da una chiave.
Si parla di \textbf{contenitore associativo} perché la mappa associa una variabile di tipo ordinabile, detta key, alle posizioni che individuano un dato, detto value. In altre parole, a ogni chiave è associato un valore memorizzato nella struttura.
Una mappa può essere vista come una collezione di elementi a coppia, chiamati \textbf{item}, ciascuno della forma ⟨\textit{key, value}⟩.

Fondamentale è il \textbf{vincolo di unicità} sulle chiavi: ogni chiave deve identificare univocamente un item nella mappa.
I valori, invece, non è obbligatorio che siano univoci: lo stesso value può essere associato a più chiavi diverse, ma non possono esistere due item con la stessa key.

Python contiene già una implementazione di Dizionario (questo per capire quanto sia importante come struttura dati). L'implementazione che fornisce Python è una di quelle che studieremo, ma non sarà l'unica possibile.
Le varie implementazioni saranno:
\begin{itemize}
    \item Mediante un array non ordinato.
    \item Mediante un array ordinato.
    \item Usando alberi di vario tipo.
    \item Usando tabella hash.
\end{itemize}

\subsection{Implementazione mediante lista doppiamente linkata non ordinata}
Implementare una Map mediante una lista doppiamente linkata non ordinata non è il massimo per quanto riguarda le performances.
\begin{itemize}
    \item Inserimento: Tempo $O(1)$
    \item Ricerca e rimozione: Tempo $O(n)$
\end{itemize}

\noindent
Nel caso pessimo bisogna scorrere l'intera lista per cercare una chiave (nel caso in cui l'elemento è l'ultimo dell'array) o renderti conto che non è presente (nel caso in cui l'elemento appunto non è contenuto).

\subsection{Sorted Map}
Una \textbf{Sorted Map} è una mappa che mantiene gli item ordinati in base alle chiavi. Questo ovviamente implica che le chiavi debbano essere di un tipo di valore ordinabile.

Gli item sono ordinati in base all'ordinamento delle chiavi.
La sorted map supporta un'operazione chiamata “Nearest Neighbour”.
Questa operazione implica che, rispetto alla mappa non ordinata, possiamo fare una ricerca e sapere con tempo $O(1)$ il successore ed il predecessore, questo può essere utile quando cerchiamo una chiave che non è contenuta nella SortedMap per conoscere la chiave più vicina al valore oggetto della nostra ricerca.

\begin{itemize}
    \item Successore: Data una chiave K mi dici qual è la chiave più piccola tra tutte quelle che sono maggiori k.
    \item Predecessore: Data una chiave K mi dici qual è la chiave più grande tra tutte quelle che sono minori k.
\end{itemize}

\noindent
Non solo, sfruttando sempre la proprietà dell'ordinamento possiamo dire il massimo ed il minimo dell'intera mappa.

\vspace{1\baselineskip}
Una possibile implementazione di Sorted Map è quella mediante un array ordinato.
In questo caso, per inserire un nuovo item, dobbiamo trovare la posizione corretta per mantenere l'ordinamento.
Questo richiede una ricerca binaria, che ha un costo di $O(\log n)$, seguita da uno spostamento degli elementi per fare spazio al nuovo item, che ha un costo di $O(n)$ nel caso pessimo.
Quindi, l'inserimento in una Sorted Map implementata con un array ordinato ha un costo complessivo di $O(n)$.

Questa implementazione può essere efficiente se la struttura dati viene utilizzata per effettuare ricerche frequenti con pochissime operazioni di inserimento/cancellazione.