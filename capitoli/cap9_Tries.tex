\chapter{Tries}
\label{cap:Tries}

Il problema del \emph{pattern matching} presentato nel capitolo \ref{cap:PatternMatching} velocizza la ricerca in un testo effettuando una pre-elaborazione del pattern (per calcolare la funzione di fallimento nell'algoritmo di Knuth-Morris-Pratt o la funzione last nell'algoritmo di Boyer-Moore). In questa sezione, adottiamo un approccio complementare, presentando algoritmi di ricerca di stringhe che effettuano una pre-elaborazione del testo. Questo approccio è adatto per applicazioni in cui viene eseguita una serie di query su un testo fisso, in modo che il costo iniziale della pre-elaborazione del testo sia compensato da un'accelerazione in ogni query successiva. A questo proposito introduciamo i \emph{tries} (pronunciato "try"), una struttura dati basata su alberi per memorizzare stringhe al fine di supportare un rapido pattern matching. La principale applicazione dei tries è nel recupero delle informazioni, da cui il nome "trie" che deriva dalla parola "retrieval".


\section{Standard Tries}
Sia $S$ un insieme di $s$ stringhe su un alfabeto $\Sigma$ tale che nessuna stringa in $S$ sia prefisso di un'altra stringa. Uno \textbf{Standard Trie} per $S$ è un albero ordinato $T$ con le seguenti proprietà:
\begin{itemize}
    \item Ogni nodo di $T$, eccetto la radice, è etichettato con un carattere di $\Sigma$.
    \item I figli di un nodo interno di $T$ hanno etichette distinte.
    \item $T$ ha $s$ foglie, ciascuna associata a una stringa di $S$, tale che la concatenazione delle etichette dei nodi sul percorso dalla radice a una foglia $v$ di $T$ dia la stringa di $S$ associata a $v$.
\end{itemize}

\noindent
Dunque, un trie $T$ rappresenta le stringhe di $S$ tramite i percorsi dalla radice alle foglie di $T$. È importante assumere che nessuna stringa in $S$ sia prefisso di un'altra sintra poichè ciò garantisce che ogni stringa di $S$ sia univocamente associata a una foglia di $T$. Possiamo sempre soddisfare questa assunzione aggiungendo un carattere speciale che non è nell'alfabeto originale $\Sigma$ alla fine di ogni stringa.

\clearpage
\noindent
Uno standard trie che memorizza una collezione $S$ di $s$ stringhe di lunghezza totale $n$ da un alfabeto $\Sigma$ ha le seguenti proprietà:
\begin{itemize}[nosep]
    \item L'altezza di $T$ è uguale alla lunghezza della stringa più lunga in $S$.
    \item Ogni nodo interno di $T$ può avere da 1 a $|\Sigma|$ figli.
    \item $T$ ha $s$ foglie.
    \item Il numero di nodi di $T$ è al più $n+1$. 
        \begin{itemize}
            \item Infatti, il caso peggiore per il numero di nodi di un trie si verifica quando nessuna coppia di stringhe condivide un prefisso non vuoto; cioè, ad eccezione della radice, tutti i nodi interni hanno un solo figlio.
        \end{itemize}
\end{itemize}

\subsection*{Ricerca}
Un trie $T$ per un insieme $S$ di stringhe permette di implementare una mappa in cui le chiavi sono le stringhe stesse; la ricerca di una stringa $X$ avviene tracciando dalla radice il percorso indicato dai caratteri di $X$ e, se tale percorso termina in un nodo foglia, la stringa è presente nella mappa, mentre se il percorso si interrompe o termina in un nodo interno la stringa non è una chiave valida. 

Il tempo di esecuzione per cercare una stringa di lunghezza $m$ è limitato superiormente da $O(m \cdot |\Sigma|)$, in quanto possiamo visitare al più $m+1$ nodi di $T$ e spendiamo $O(|\Sigma|)$ tempo in ogni nodo per determinare il figlio che ha come etichetta il carattere successivo. Tuttavia, possiamo migliorare il tempo speso in un nodo a $O(\log |\Sigma|)$ o atteso $O(1)$, mappando i caratteri ai figli utilizzando una tabella hash in ogni nodo, oppure utilizzando una lookup table diretta di dimensione $|\Sigma|$ in ogni nodo, se $|\Sigma|$ è sufficientemente piccolo (come nel caso delle stringhe di DNA). Per questi motivi, ci aspettiamo tipicamente che una ricerca per una stringa di lunghezza $m$ venga eseguita in tempo $O(m)$.

\subsection*{Word Matching}
Grazie a queste caratteristiche, il trie è adatto per il \textbf{word matching esatto} e per le query sui prefissi (per via dell'operazione di ricerca appena descritta), ma non per il pattern matching di sottostringhe arbitrarie. Il \emph{word matching} è un caso particolare di pattern matching in cui vogliamo determinare se un dato pattern corrisponde esattamente a una delle parole del testo. Il word matching si differenzia dal pattern matching standard analizzato nel capitolo \ref{cap:PatternMatching} perché in questo caso il pattern non può corrispondere a una sottostringa arbitraria del testo, ma solo a una delle sue parole.

\subsection*{Costruzione di uno Standard Trie}
Per costruire uno standard trie per un insieme $S$ di stringhe, possiamo utilizzare un algoritmo incrementale che inserisce le stringhe una alla volta. Ricordiamo l'assunzione che nessuna stringa di $S$ sia prefisso di un'altra stringa. Per inserire una nuova stringa $X$ nel trie, seguiamo il percorso dei suoi caratteri finché esistono nodi corrispondenti. Nel punto in cui il percorso esistente si interrompe (ovvero non troviamo il carattere successivo), creiamo una nuova sequenza di nodi per tutti i caratteri restanti di $X$. Il tempo di esecuzione per inserire $X$ di lunghezza $m$ è simile a una ricerca, con prestazioni nel caso peggiore di $O(m \cdot |\Sigma|)$, o attese $O(m)$ se si utilizzano tabelle hash secondarie in ogni nodo. Pertanto, la costruzione dell'intero trie per l'insieme $S$ richiede un tempo atteso di $O(n)$, dove $n$ è la lunghezza totale delle stringhe di $S$.

\vspace{1\baselineskip}
\begin{figure}[!ht]
    \centering
    \includegraphics[width=1\textwidth]{immagini/Tries/std_tries_ex.png}
    \caption{Word Matching tramite uno Standard Trie: (a) testo da cercare (articoli e preposizioni, noti anche come stop words, esclusi); (b) standard trie per le parole nel testo, con le foglie che mantengono l'informazione relativa all'indice in cui la data parola inizia nel testo. Ad esempio, la foglia per la parola \emph{stock} indica che la parola inizia agli indici 17, 40, 51 e 62 del testo.}
    \label{fig:std_tries_ex}
\end{figure}

\vspace{1\baselineskip}
Come si può notare anche dall'esempio in Figura \ref{fig:std_tries_ex}, c'è una potenziale inefficienza di spazio nello standard trie dovuta alla presenza di molti nodi che hanno un solo figlio, e l'esistenza di tali nodi rappresenta uno spreco. La ricerca di una soluzione a questo problema ha portato allo sviluppo del \emph{Compressed Trie}, o \emph{Patricia Trie}.  


\clearpage
\section{Compressed Tries}
Un \textbf{Compressed Trie} è una variante dello standard trie che garantisce che ogni nodo interno del trie abbia almeno due figli. Questa regola viene applicata comprimendo le catene di nodi con un solo figlio. 

Sia $T$ un trie standard. Diciamo che un nodo interno $v$ di $T$ è \textbf{ridondante} se $v$ ha un solo figlio e non è la radice. Diciamo anche che una \emph{catena} di $k \geq 2$ archi,
$$ (v_0, v_1)(v_1, v_2) \cdots (v_{k-1}, v_k) $$
è \textbf{ridondante} se:
\begin{itemize}[nosep]
    \item $v_i$ è ridondante per ogni $i = 1, \ldots, k-1$.
    \item $v_0$ e $v_k$ non sono ridondanti.
\end{itemize}

\noindent
Si può trasformare $T$ in un \emph{Compressed Trie} sostituendo ogni catena ridondante $(v_0,v_1) \cdots (v_{k-1},v_k)$ di $k \geq 2$ archi con un singolo arco $(v_0,v_k)$, rietichettando $v_k$ con la concatenazione delle etichette dei nodi $v_1, \ldots, v_k$.

\begin{figure}[!ht]
    \centering
    \includegraphics[width=1\textwidth]{immagini/Tries/compressed_tries_ex.png}
    \caption{Compressed Trie per le stringhe \{bear, bell, bid, bull, buy, sell, stock, stop\}. (Confronta questo con lo standard trie mostrato in Figura \ref{fig:std_tries_ex}.) Oltre alla compressione ai nodi foglia, nota il nodo interno con etichetta "to" condivisa dalle parole "stock" e "stop".}
    \label{fig:compressed_tries_ex}
\end{figure}

\noindent
I nodi di un compressed trie sono etichettati con delle stringhe, che sono sottostringhe delle stringhe nella collezione, piuttosto che con singoli caratteri. Il vantaggio di un compressed trie rispetto a uno standard trie è che il numero di nodi del compressed trie è proporzionale al numero di stringhe e non alla loro lunghezza totale.

\vspace{1\baselineskip}
\noindent
Un compressed trie che memorizza una collezione $S$ di $s$ stringhe in un alfabeto di dimensione $d$ ha le seguenti proprietà:

\begin{itemize}
    \item Ciascun nodo interno di $T$ ha almeno due figli e al massimo $d$ figli.
    \item $T$ ha $s$ nodi foglia.
    \item Il numero di nodi di $T$ è $O(s)$.
\end{itemize}

\clearpage
\noindent
Il \emph{Compressed Trie} offre un reale vantaggio quando viene utilizzato come struttura di indicizzazione ausiliaria per una collezione di stringhe già memorizzate in una struttura primaria.

Supponiamo, ad esempio, che la collezione $S$ di stringhe sia un array di stringhe $S[0], S[1], \ldots, S[s-1]$. Invece di memorizzare esplicitamente l'etichetta $X$ di un nodo, la rappresentiamo implicitamente mediante una combinazione di tre interi $(i, j : k)$, tali che $X = S[i][ j : k]$; cioè, $X$ è la porzione di $S[i]$ costituita dai caratteri dalla posizione $j$ fino a, ma non includendo, la posizione $k$.

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.9\textwidth]{immagini/Tries/compressed_tries_usage.png}
    \caption{(a) Collezione $S$ di stringhe memorizzata in un array. (b) Rappresentazione compatta del compressed trie per $S$.}
    \label{fig:compressed_tries_usage}    
\end{figure}

\noindent
In questo modo è possibile ridurre lo spazio totale per il trie stesso da $O(n)$ per lo standard trie a $O(s)$ per il compressed trie, dove $n$ è la lunghezza totale delle stringhe in $S$ e $s$ è il numero di stringhe in $S$. Naturalmente, dobbiamo comunque memorizzare le diverse stringhe in $S$, ma riduciamo comunque lo spazio per il trie.

La ricerca in un compressed trie non è necessariamente più veloce che in un albero standard, poiché è ancora necessario confrontare ogni carattere del pattern desiderato con le etichette, potenzialmente multi-carattere, durante la traversata dei percorsi nel trie.



\clearpage
\section{Suffix Tries}
Un \textbf{Suffix Trie} (o \emph{Suffix Tree}) per una stringa $X$ è un trie che contiene tutti i suffissi di $X$.

Per un Suffix Trie, la rappresentazione compatta presentata nella sezione precedente può essere ulteriormente semplificata. In particolare, l'etichetta di ogni vertice è una coppia $(j,k)$ che indica la stringa $X[j : k]$. Al fine di soddisfare la regola che nessun suffisso di $X$ sia prefisso di un altro suffisso, possiamo aggiungere un carattere speciale, denotato con \$ (che non è nell'alfabeto originale $\Sigma$) alla fine di $X$ (e quindi a ogni suffisso). 

Al netto di tutto ciò, se la stringa $X$ ha lunghezza $n$, costruiamo un trie per l'insieme di $n$ stringhe $X[j : n]$, per $j = 0, \ldots, n-1$.

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.79\textwidth]{immagini/Tries/suffix_trie.png}
    \caption{(a) Suffix trie $T$ per la stringa $X$ = "minimize". (b) Rappresentazione compatta di $T$, dove la coppia $(j:k)$ denota la porzione $X[j:k]$ nella stringa di riferimento.}
    \label{fig:suffix_trie}
\end{figure}

\noindent
Per costruire un Suffix Trie possiamo procedere in modo simile alla costruzione di uno Standard Trie (compresso). In breve, si segue il cammino esistente finché coincide; dove il cammino finisce o diverge si crea una diramazione.

La lunghezza totale dei suffissi di una stringa $X$ di lunghezza $n$ è pari a:
$$ 1 + 2 + \cdots + n = \frac{n(n+1)}{2} = O(n^2) $$
Nonostante ciò, il suffix trie può essere costruito in spazio O(n) poiché molte porzioni dei suffissi condividono prefissi comuni.
\noindent
La costruzione di un Suffix Trie richiede un tempo $O(n^2)$, anche se in realtà esiste un algoritmo più complesso (che non approfondiremo) che costruisce un Suffix Trie in tempo $O(n)$.

\clearpage


\section{Pattern Matching con Suffix Tries}
Il Suffix Trie $T$ per una stringa $X$ può essere utilizzato per eseguire efficientemente query di pattern-matching sul testo $X$. 

Supponiamo di voler cercare un pattern $P$ di lunghezza $m$ e sia $D$ un testo di lunghezza $n$ (di solito $n \gg m$). Siamo in grado di trovare un'occorrenza di $P$ in $D$ con $O(n)$ pre-processing del testo, $O(m)$ per la ricerca e uno spazio utilizzato $O(n)$.
\begin{itemize}
    \item Se dobbiamo ricercare un nuovo pattern $P'$ in $D$, abbiamo bisogno solamente di un tempo $O(m')$, dove $m'$ è la lunghezza di $P'$.
    \item Questo metodo è più efficiente di \emph{BM} o \emph{KMP} quando il testo è fisso e disponibile per essere pre-elaborato in anticipo.
\end{itemize}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=1\textwidth]{immagini/Tries/st_pattern_matching.png}
    \caption{Il pattern viene trovato in posizione: $8 - \text{len}(Y) = 5$}
    \label{fig:st_pattern_matching}
\end{figure}

\noindent
Eseguiamo il pattern matching come segue:
\begin{itemize}
    \item Costruiamo il Suffix Trie $T$ per il testo $D$, il che può essere fatto in $O(n)$ con uno spazio $O(n)$.
    \item Confronta i caratteri di $P$ lungo l'unico percorso corrispondente in $T$ fino a quando:
    \begin{itemize}
        \item Tutti i caratteri di $P$ sono stati confrontati con successo (in questo caso, $P$ si trova in $D$).
        \item Non sono possibili ulteriori match (in questo caso, $P$ non si trova in $D$).
    \end{itemize}
    \item Se $P$ è stato trovato, possiamo recuperare la posizione di $P$ all'interno di $D$ nel modo seguente: 
    \begin{itemize}
        \item Sia $v$ il nodo in cui termina il confronto, con etichetta $(j, k)$.
        \item Sia $Y$ la stringa di lunghezza $y$ corrispondente al percorso dalla radice a $v$.
        \item L'indice del primo carattere di $P$ in $D$ è dato da $k - y$.
    \end{itemize}
\end{itemize}


\clearpage
\section{The Substring Problem}
In questa tipologia di problema abbiamo a disposizione un insieme noto e fissato di stringhe che chiameremo \textbf{database dei pattern}. Successivamente ci viene fornita una stringa $S$ per cui vogliamo trovare tutti i pattern nel database che contengono $S$ come sottostringa\footnote{
    Un'applicazione di questo problema riguarda l'autocompletamento all'interno di un IDE. Nel database rientrano tutti i nomi delle classi, metodi e variabili definite dal programmatore, mentre la stringa S rappresenta quello che si sta digitando (es. "List"). Come risultato l'IDE mostra istantaneamente non solo ciò che inizia con "List", ma tutto ciò che lo contiene (es. ArrayList, LinkedList, ListListener).
}. 

Osservando attentamente questo problema notiamo che si tratta in effetti del problema duale del \emph{pattern matching}, in cui abbiamo un testo fisso e cerchiamo un pattern variabile. Qui, invece, abbiamo un insieme fisso di pattern e cerchiamo una sottostringa che variabile.

Supponiamo che la lunghezza totale delle stringhe nel database sia pari a $m$. Siccome normalmente questo valore $m$ può essere molto grande, vogliamo limitare lo spazio utilizzato per memorizzare il database, limitare il tempo necessario per il pre-processing e limitare la fase di ricerca il più possibile.

\subsection*{Soluzione}
La soluzione a questo problema sfrutta proprio i \textbf{Suffix Tries}, che come abbiamo visto sono capaci di rispettare i vincoli di spazio e tempo richiesti.
\begin{itemize}
    \item Costruiamo un Suffix Trie $T$ per l'insieme dei pattern nel database, che quindi conterrà tutti i suffissi di tutti i pattern. Questo richiede un tempo $O(m)$ e uno spazio $O(m)$.
    \item Ogni nodo $v$ in $T$ mantiene una lista di tutti i pattern che contengono la stringa rappresentata dal percorso dalla radice a $v$.
    \item Per cercare una stringa $S$ di lunghezza $n$, seguiamo il percorso in $T$ indicato dai caratteri di $S$. Se la ricerca termina con successo in un nodo $v$, allora tutti i pattern nella lista associata a $v$ contengono $S$ come sottostringa. Se il percorso si interrompe prima di raggiungere un nodo, allora nessun pattern nel database contiene $S$ come sottostringa.
    \begin{itemize}
        \item Se la ricerca ha successo, e $v$ è un nodo foglia, la stringa $S$ è proprio un pattern del database.
        \item Se la ricerca ha successo, e $v$ è un nodo interno, la lista associata a $v$ contiene tutti i pattern che contengono $S$ come sottostringa.
        \item Se la ricerca fallisce in un nodo $f$, il percorso per cui si ha avuto un match (parziale) fino a quel punto rappresenta il prefisso più lungo di $S$ che è anche una sottostringa di almeno un pattern nel database.
    \end{itemize}
    \item La ricerca richiede un tempo $O(n)$, dove $n$ è la lunghezza di $S$.
\end{itemize}



\clearpage
\section{Longest Common Substring: two strings}
Ricordiamo che una sottostringa $S[i:j]$ di una stringa $S$ è data dai caratteri $S[i], \ldots, S[j-1]$.
Una stringa $S$ è una \textbf{sottostringa comune} di due stringhe $S_1$ e $S_2$ se ci esistoni degli indici $i, j, i', j'$ tali che $S = S_1[i:j] = S_2[i':j']$.

Il problema della \emph{longest common substring} (LCS) consiste nel trovare la sottostringa comune più lunga, in questo caso tra due sole stringhe.


\subsection*{Soluzione}
Siano $m_1$ e $m_2$ le lunghezze delle due stringhe $S_1$ e $S_2$, e sia $m = m_1 + m_2$. La sottostringa comune più lunga tra due stringe può essere trovata in tempo $O(m)$ e spazio $O(m)$ utilizzando un Suffix Trie, come segue:
\begin{itemize}
    \item Costruiamo un Suffix Trie $T$ che contiene entrambe le stringhe (e i loro suffissi) e memorizziamo in ogni nodo un'etichetta con uno dei valori $\{1, 2, 1/2\}$ a seconda che il suffisso provenga da $S_1$, $S_2$ o entrambi.
    \begin{itemize}
        \item Questo richiede un tempo $O(m)$ e uno spazio $O(m)$.
    \end{itemize}
    \item Cerchiamo un nodo $v$ di $T$ con etichetta $1/2$ tale che la lunghezza della stringa corrispondente al percorso dalla radice a $v$ sia massima.
    \begin{itemize}
        \item Richiede di visitare al più tutti i nodi di $T$, quindi richiede un tempo $O(m)$.
    \end{itemize}
    \item La stringa corrispondente al percorso dalla radice a $v$ è la sottostringa comune più lunga tra $S_1$ e $S_2$.
\end{itemize}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=1\textwidth]{immagini/Tries/lcs_two_strings.png}
    \caption{Il simbolo \$ viene utilizzato per fare in modo che nessuna stringa sia prefisso di un'altra all'interno di $D$.}
    \label{fig:lcs_two_strings}
\end{figure}





\clearpage
\section{Longest Common Substring: many strings}
Generalizziamo ora il problema della \emph{longest common substring} (LCS) a più di due stringhe.
Supponiamo di avere $K$ stringhe la cui lunghezza totale è $m$. Per ogni $k$ compreso tra $2$ e $K$, definiamo $l(k)$ come la lunghezza della sottostringa comune più lunga per almeno $k$ delle $K$ stringhe. Il problema della LCS per più stringhe consiste nel calcolare i valori $l(2), l(3), \ldots, l(K)$ e le stringhe corrispondenti.

\paragraph{Esempio:} Sia $S$ = \{ \emph{sandollar, sandlot, handler, grand, pantry} \}. In questo caso, $l(2) = 4$ (la sottostringa comune più lunga tra almeno due stringhe è \emph{sand}), $l(3) = 3$ (la sottostringa comune più lunga tra almeno tre stringhe è \emph{and}), $l(4) = 3$ (è ancora \emph{and}) e $l(5) = 2$ (\emph{an}).


\subsection*{Soluzione}
\begin{itemize}
    \item Costruiamo un \textbf{Suffix Tree generalizzato}\footnote{Un \emph{Suffix Tree generalizzato} rappresenta tutti i suffissi di un insieme di stringhe, anziché di una singola stringa; Nota: è stato utilizzato nelle soluzioni dei paragrafi precedenti ai problemi proposti} $T$ per le $K$ stringhe.
    \begin{itemize}
        \item Ogni nodo foglia di $T$ rappresenta un suffisso di una delle $K$ stringhe e viene etichettato con l'indice della stringa a cui appartiene.
        \begin{itemize}
            \item Anche in questo caso, per garantire che nessuna stringa sia prefisso di un'altra, aggiungiamo un carattere speciale unico alla fine di ogni stringa.
        \end{itemize}
        \item Per ogni nodo interno $v$ di $T$, calcoliamo $C(v)$ come il numero di identificatori di stringa distinti che compaiono alle foglie del sottoalbero radicato in $v$.
        \begin{itemize}
            \item Questa operazione è il \textbf{collo di bottiglia della soluzione} e può essere eseguita in tempo $O(K \cdot m)$.
        \end{itemize}
        \item Per ogni nodo $v$ di $T$, calcoliamo la lunghezza della stringa corrispondente al percorso dalla radice a $v$.
    \end{itemize}

    \item I valori di $l(k)$ possono essere calcolati facilmente visitando l'albero in tempo lineare:
    \begin{itemize}
        \item Durante questa visita, costruiamo un vettore $V$ in cui, per ogni valore di $k$ da $2$ a $K$, la cella $V(k)$ memorizza la massima string-depth trovata tra i nodi che hanno $C(v) = k$ (cioè i nodi condivisi da esattamente $k$ stringhe).
        \item Infine, calcoliamo i valori finali partendo da $k = K$ e andando a ritroso: impostiamo $l(k)$ uguale a $V(k)$ se questo è maggiore del valore successivo, altrimenti $l(k)$ eredita il valore di $l(k+1)$ (questo serve a propagare la soluzione: se una stringa è condivisa da $K$ elementi, vale anche come stringa condivisa da $K-1$).
        $$l(k) = 
        \begin{cases} 
            V(k) & \text{se } V(k) > l(k+1) \\ 
            l(k+1) & \text{altrimenti}
        \end{cases}
        $$
    \end{itemize}
\end{itemize}




