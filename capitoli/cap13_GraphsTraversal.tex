\chapter{Graphs Traversal}
\label{cap:GraphsTraversal}

Un \textbf{graph traversal algorithms} (algoritmo di attraversamento dei grafi) è una procedura sistematica per esplorare un grafo esaminando tutti i suoi vertici e archi. Un algoritmo di graph traversal è efficiente se visita tutti i vertici e archi in un tempo proporzionale al loro numero, cioè in tempo lineare

Gli algoritmi di graph traversal sono fondamentali per rispondere a molte domande fondamentali sui grafi che coinvolgono la nozione di \emph{raggiungibilità}, cioè nel determinare come viaggiare da un vertice all'altro seguendo i percorsi di un grafo. 

Gli algoritmi di graph traversal più utilizzati sono la \textbf{depth-first search} (DFS, ricerca in profondità) e la \textbf{breadth-first search} (BFS, ricerca in ampiezza). Entrambi gli algoritmi iniziano da un vertice di partenza e visitano sistematicamente tutti i vertici raggiungibili da quel vertice, ma lo fanno in modi diversi come vedremo più avanti.


\vspace{1\baselineskip}
\noindent
Alcuni problemi interessanti che trattano la raggiungibilità in un grafo non orientato $G$ includono i seguenti:
\begin{itemize}
    \item Calcolare un percorso dal vertice $u$ al vertice $v$, o segnalare che non esiste tale percorso.
    \item Dato un vertice di partenza $s$ di $G$, calcolare, per ogni vertice $v$ di $G$, un percorso con il numero minimo di archi tra $s$ e $v$, o segnalare che non esiste tale percorso.
    \item Verificare se $G$ è connesso.
    \item Calcolare un albero di copertura (spanning tree) di $G$, se $G$ è connesso.
\end{itemize}

\noindent
Alcuni riguardano in modo specifico i grafi orientati.
\begin{itemize}
    \item Calcolare un percorso diretto dal vertice $u$ al vertice $v$, o segnalare che non esiste tale percorso.
    \item Trovare tutti i vertici di $G$ raggiungibili da un dato vertice $s$.
    \item Determinare se $G$ è aciclico.
    \item Determinare se $G$ è fortemente connesso.
\end{itemize}

\clearpage
\section{Depth-First Search (DFS)}
La \textbf{Depth-First Search} (DFS) è una tecnica generale per l'attraversamento dei grafi che esplora "in profondità": parte da un nodo radice e avanza lungo ogni ramo il più possibile prima di tornare indietro (backtracking). 

L'algoritmo DFS applicato ad un grafo con $n$ vertici e $m$ archi visita tutti i vertici e archi del grafo in tempo $O(n + m)$.
In particolare, la DFS può essere usata per verificare se $G$ è connesso, calcolare le \emph{connected components} \footnote
{Una \textbf{connected component} (componente connessa) è un sottografo massimale di un \emph{grafo non orientato} in cui ogni coppia di vertici è collegata da almeno un cammino, e che non può essere esteso aggiungendo altri vertici del grafo mantenendo tale proprietà.} 
di $G$ e calcolare uno \emph{spanning forest}\footnote
{Uno \textbf{spanning tree} è un sottoinsieme di archi che connette tutti i vertici di un grafo connesso senza cicli.
Uno \textbf{spanning forest} è un insieme di spanning tree, uno per ciascuna componente connessa di un grafo non connesso.
L'algoritmo DFS genera uno spanning tree se il grafo è connesso; se il grafo non è connesso, eseguita su tutte le componenti, genera uno spanning forest.
} 
di $G$.


\begin{itemize}
    \item \textbf{DFS su un singolo vertice in un grafo non connesso:} visita solamente i vertici della \emph{connected component} contenente il vertice di partenza e costruisce uno \emph{spanning tree} di tale componente. Non permette di visitare tutti i vertici del grafo, né di verificare la connettività globale o calcolare tutte le connected components.
    
    \item \textbf{DFS su tutti i vertici non ancora visitati in un grafo non connesso:} eseguendo DFS partendo da ciascun vertice non visitato si visitano tutti i vertici del grafo. Questo procedimento permette di calcolare tutte le \emph{connected components} e di costruire uno \emph{spanning forest} del grafo. Inoltre, se una singola DFS visita tutti i vertici, il grafo è connesso.
    
    \item \textbf{DFS su un singolo vertice in un grafo connesso:} in questo caso l'esecuzione di DFS sul vertice di partenza visita tutti i vertici del grafo, costruendo uno \emph{spanning tree} dell'intero grafo e permettendo di verificare la connettività globale.
\end{itemize}

\vspace{1\baselineskip}
\noindent
L'idea di base dell'algoritmo DFS è la seguente:
\begin{itemize}
    \item DFS inizia da un vertice sorgente $s$ e marca $s$ come visitato.
    \item Quando DFS arriva in un vertice $u$ non ancora visitato:
    \begin{itemize}[nosep]
        \item Se esiste un arco $(u, v)$ che conduce a un vertice $v$ non ancora visitato, DFS prende tale arco, marca $v$ come visitato e applica ricorsivamente lo stesso algoritmo su $v$.
        \item Se non ci sono archi che conducono a vertici non ancora visitati, DFS torna indietro lungo il percorso fino a raggiungere un vertice che ha dei vicini non ancora visitati.
        \end{itemize}
    \item Quando una chiamata DFS termina:
    \begin{itemize}[nosep]
        \item Se ci sono vertici non ancora visitati, se ne sceglie uno e si ripete il processo. Ogni chiamata DFS completa esplora una singola \emph{connected component}.
        \item Se tutti i vertici sono stati visitati, l'algoritmo termina.
    \end{itemize}
\end{itemize}


\clearpage
\noindent
Per implementare DFS abbiamo bisogno di etichettare i vertici e gli archi del grafo:

\begin{itemize}
    \item Ogni vertice può essere in uno dei seguenti stati:
    \begin{itemize}[nosep]
        \item \textbf{Unexplored}: il vertice non è stato ancora visitato.
        \item \textbf{Visited}: il vertice è stato già visitato.
    \end{itemize}
    \item Ogni arco può essere in uno dei seguenti stati:
    \begin{itemize}[nosep]
        \item \textbf{Unexplored}: l'arco non è stato ancora esplorato.
        \item \textbf{Discovery}: l'arco è stato esplorato per raggiungere un vertice non ancora visitato. Questo arco fa parte dello spanning tree.
        \item \textbf{Back edge}: l'arco è stato esplorato e conduce a un vertice già visitato. Questo arco non fa parte dello spanning tree.
    \end{itemize}
\end{itemize}



\vspace{1\baselineskip}
\hrule
\begin{verbatim}
Input: graph G
Output: labeling of the edges of G as discovery or back
1.  Algorithm DFS(G):
2.      for all u in G.vertices()
3.          setLabel(u, UNEXPLORED)
4.      for all e in G.edges()
5.          setLabel(e, UNEXPLORED)
6.      for all v in G.vertices()
7.          if getLabel(v) = UNEXPLORED
8.              DFS-Visit(G, v)
\end{verbatim}
\hrule 
\vspace{1\baselineskip}



\vspace{1\baselineskip}
\hrule
\begin{verbatim}
Input: graph G and a source vertex v
Output: labels for the edges in the connected component 
of G containing v
1.  Algorithm DFS(G,v):
2.    setLabel(v, VISITED)
3.    for all e in G.incidentEdges(v)
4.        if getLabel(e) = UNEXPLORED
5.            w = opposite(v,e)
6.            if getLabel(w) = UNEXPLORED
7.                setLabel(e, DISCOVERY)
8.                DFS(G, w)
9.            else
10.               setLabel(e, BACK)

\end{verbatim}
\hrule 
\vspace{1\baselineskip}

\clearpage
\begin{figure}
    \centering
    \includegraphics[width=0.97\textwidth]{immagini/GraphsTraversal/DFS_ex.png}
    \caption{Esempio di DFS su un grafo non orientato a partire dal vertice A. Supponiamo che le adiacenze di un vertice siano considerate in ordine alfabetico. I vertici visitati e gli archi esplorati sono evidenziati, con gli archi di scoperta (discovery) disegnati come linee solide e gli archi non appartenenti all'albero (back edges) come linee tratteggiate; i vertici e gli archi non evidenziati sono tutti unexplored: (a) grafo di input; (b) percorso degli archi dell'albero, tracciato da A fino a quando viene esaminato l'arco di back (G,C); (c) raggiungimento di F, che è un vicolo cieco; (d) dopo il backtracking a I, riprendendo con l'arco (I,M), e raggiungendo un altro vicolo cieco in O; (e) dopo il backtracking a G, continuando con l'arco (G,L), e raggiungendo un altro vicolo cieco in H; (f) risultato finale.}
    \label{fig:DFS_ex}
\end{figure}

\clearpage
\noindent
Riportiamo due proprietà fondamentali dell'algoritmo DFS:
\begin{enumerate}
    \item Sia $G$ un \textbf{grafo non orientato} su cui è stata eseguita una DFS a partire da un vertice $s$. Allora la visita DFS copre tutti i vertici della componente connessa di $s$, e gli archi di discovery formano uno spanning tree della componente connessa di $s$.
    \begin{itemize}
        \item Calcolare uno spanning tree della componente connessa di $s$ vuol dire trovare un cammino da $s$ a ogni altro vertice raggiungibile da $s$.
    \end{itemize}
    \item Sia $G$ un \textbf{grafo orientato}. La depth-first search su $G$ a partire da un vertice $s$ visita tutti i vertici di $G$ raggiungibili da $s$. Inoltre, l'albero DFS contiene percorsi orientati da $s$ a ogni vertice raggiungibile da $s$.
\end{enumerate}


\subsection{Analisi e implementazione dell'algoritmo DFS}
Nell'algoritmo di visita in profondità (Depth First Search, DFS) ogni vertice del grafo viene etichettato esattamente due volte: inizialmente come \emph{UNEXPLORED}, e successivamente come \emph{VISITED} nel momento in cui viene effettivamente visitato dall'algoritmo. Analogamente, ogni arco viene etichettato due volte: la prima volta come \emph{UNEXPLORED} quando viene incontrato per la prima volta, e la seconda volta come \emph{DISCOVERY} oppure \emph{BACK}, a seconda che conduca rispettivamente a un vertice non ancora visitato oppure a un vertice già visitato. Le operazioni di lettura e scrittura delle etichette associate a vertici e archi richiedono tempo costante \(O(1)\). Inoltre, il metodo \texttt{incidentEdges(v)}, che restituisce tutti gli archi incidenti a un vertice \(v\), viene invocato una sola volta per ciascun vertice del grafo. Se il grafo è rappresentato mediante Adjacency List o Adjacency Map, il tempo necessario per eseguire \texttt{incidentEdges(v)} è proporzionale al grado del vertice \(v\), cioè \(O(\deg(v))\). Sommando tale costo su tutti i vertici del grafo, si ottiene \(\sum_{v} \deg(v) = 2m\), dove \(m\) è il numero di archi del grafo. Ne consegue che il tempo totale impiegato dall'algoritmo DFS è \(O(n + m)\), dove \(n\) è il numero di vertici e \(m\) il numero di archi.










